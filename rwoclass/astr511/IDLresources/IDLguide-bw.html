<!-- University of Virginia Department of Astronomy -->
<!-- All contents copyright (C) 1991-2015.  All rights reserved to author. -->
<!-- Contact: rwo@virginia.edu -->
<!-- Original Home URL: http://www.faculty.virginia.edu/rwoclass/astr511/IDLresources/IDLguide.html  -->
<!-- Home URL: https://rwoconne.github.io/rwoclass/astr511/IDLresources/IDLguide.html -->
<!--  -->

<html>
<head>

<link rel=stylesheet href="idl-1.css" type="text/css">
<TITLE> Introduction to IDL </TITLE>

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="description" content="Description of basic operation of the
Interactive Data Language (IDL) for image processing and data
analysis in astronomy.  Developed for course ASTR 511, Astronomical Techniques,
at the University of Virginia.  Robert W. O'Connell 1997-2012."  >

<meta name="keywords" content="astronomy, data analysis, image
processing, IDL, interactive data language, interactive computing">

<style>
     div.all {  max-width: 900px;}
 </style>

</head>

<body>
<div class="all">

<!--
<body bgcolor="#252525" text="yellow"  link="#00FF00" vlink="#00FF00" alink="#FF0000" > 
-->

<table width=100% border=0>
<tr>
<td align="left">
<h3> VERSION: JUNE 2012  </h3>
</td>
<td align="right">
<!-- Temp delete
<font size="-1"><a href="IDLguide-bw.html"><b>Click here for B&W version</a></font></p>
-->
</td></tr>
</table>

<!-- History: Plain text version: 91; 3 Sept 93; 23 Oct 95; 11 Jun 96; 19
     Jan 97; 17 Mar 97;
     23 Jun 97; 18 Aug 97; 22 Aug 97; 26 Aug 97; 1 Sept 97; 2 Sept 97 -->

<!-- Begin HTML conversion. Text not updated. 
     4 Sept 97; 5 Sept 97; 8 Sept 97; 9 Sept 97; 12 Sept 97; 14 Sept 97 
     15 Sept 97; 16 Sept 97; 17 Sept 97; add database info 18 Sept 97 
     20 Sept 97; 22 Sept 97; 6 Oct 97; 20 Oct 97; 4 Dec 97; 8 Dec 97;  25 Mar 98 (typo);  -->

<!--
     Begin major update: 4 Apr 01; 24 Apr 01; 25 Apr; 22 May; 23 May;
     24 May; 25 May 26 May; 27 May; 29 May; 2 June; 4 June; 26 June;
     30 June; 1 July; 2 July; 5 July; 6 July; 7 July; 8 July; 9 July;
     10 July; 11 July; 12 July; 20 July; 21 July; 23 July; 24 July; 25
     July; 29 July; 10 Aug; 16 Aug; Begin update: 27 Nov 2002; 28 Nov;
     29 Nov; 30 Nov; 1 Dec; 2 Dec; 3 Dec; 4 Dec; 15 Dec (typo); 22
     Dec; 31 Dec; 6 Jan 2003; 28 Mar; 28 May; 29 May; 30 May; 17 June
     (update for WBL MOUSSE routine site); 10 July small mods, add link
     to "black & white" printable version; 18 July; 29 July (path
     names for UVa s/w changed); 30 July; 14 March 2004 (contents
     mod); 8/4; 8/6; 8/10; 8/23; 8/24; 8/25; 8/31; 9/2; 9/14; 9/17;
     Begin update:  10/4; 10/5; 11/30; 12/8; 12/9; 2/1/2005; 2/3; 2/9;
     2/15; 3/20/2007: HTML format update only; 3/3/2009: begin small
     updates, including color scheme, use of css; 3/09; 3/18; 3/22;
     4/17; becomes a major upgrade, including re-ordering of
     introductory material; 6/17; 6/19; 7/03; 7/05; 7/06; 7/07; 7/08;
     7/11; 7/14; 7/16; 8/03; 8/04; 8/06; 8/07; 8/08; 8/09; 8/10; 8/11;
     8/12; 8/13; 8/15; 8/16; 8/17; 8/18; 8/19; 8/20; 8/21; 8/22; 8/23; 
     8/24; 8/25; 8/26; POSTED; 9/06; 9/13; 9/20; 9/22; 9/28; 
     10/10 (revise css file for easy BW conversion); 10/19; 10/20;
     10/21; 12/04; 12/05; 12/07; 12/08; 12/09; 12/16; 12/17; 12/18;
     12/23; 12/24; 12/25; 12/26; 1/10/2010; 1/11; 1/13; 1/15; 1/16; 
     1/17; 1/21; 1/22; 1/25 [POSTED version--reorder file read/write,
     elaborate on plots, move ATV section, etc]; 4/04; 4/08; 4/15; 
     6/10; 7/1; 7/3; 7/4; 7/6 [POSTED version--mostly touchups; a few adds, 
     small rearrangements]; 7/13; 7/28 - minor updates; 4/15/2011: add
     link to Belorussian translation by Bohdan Zograf [POSTED]; 
     2/12/2012: change ITT to Exelis; change links to man.pro because
     WL distribution no long includes it; 2/12; [POSTED]; 2/26: German
     translation link added; [POSTED]; 4/19: Russian translation link added
     [POSTED]; 6/7: typos fixed & revise discussion of UVa idl_env.csh;  
     9/18/2015: change webpage domain in links to 
     www.faculty.virginia.edu/rwoclass  [POSTED];

     GHP version:  12/15/2020; 12/19: eliminate more faculty.virginia links;  

-->


<h1 align=center><u>A GUIDE TO IDL FOR ASTRONOMERS</u> </h1>

<h2 align=center>  R. W. O'Connell </h2>

<hr size=3 >

<p><br></p>


<a name="contents"> <h2>  Contents </h2> </a>

<ul>

<li> <a href="#int"> I. Introduction </a><p>
<ul>

<li> <a href="#key">1.  Key Features of IDL</a>

<li> <a href="#context"> 2.  IDL in Context </a>

<li> <a href="#pack"> 3. IDL Applications Packages </a>

<li> <a href="#back"> 4.  The IDL Environment</a>

<li> <a href="#limits"> 5. IDL Limitations </a>

<li> <a href="#resources"> 6.  Demos, Tutorials, Software List</a></p> 

</ul>

<li> <a href="#guide"> II.  Guide to Image Processing with IDL</a><p>

<ul>

<li> <a href="#start">1.  Starting & Stopping IDL </a>

<li> <a href="#help"> 2. Help </a>

<li> <a href="#prog"> 3. Program Execution </a>

<li> <a href="#retrieve"> 4. Data and Image Retrieval </a>

<li> <a href="#display"> 5. Image Display </a>

<li> <a href="#inspect"> 6. Data Inspection & Manipulation</a>

<ul>
<li> <a href="#ATV">The ATV Image Display & Inspection Tool</a>
</ul>

<li> <a href="#store"> 7.  Data and Image Storage

<li> <a href="#phot"> 8. Image Photometry </a>

<!-- <li> <a href="#ascii"> 9. ASCII Files </a>  -->

<li> <a href="#dbase"> 9. Database Access </a>

<li> <a href="#plots "> 10. Plots </a>

<li> <a href="#hard"> 11. Graphics Hardcopy </a>

<li> <a href="#hints"> 12. IDL Hints and Annoyances </a><p>

</ul>


<li> <a href="#setup"> III. Appendices </a><p>

<ul>
<li> <a href="#setup"> Appendix A: IDL Setup</a>

<li> <a href="#envex">  Appendix B:  Environment Setup Example </a>

<li> <a href="#startex"> Appendix C: MOUSSE Startup File Example </a>

<li> <a href="#windows"> Appendix D:  X-Windows Notes </a>

</ul> </ul>


<a name="translations"> <h2>Translations </h2> </a>

<ul>

<li> <a href="http://webhostingrating.com/libs/IDLguide-be">Belorussian
Translation</a>

<li> <a href="http://www.leiste.de/science/a-guide-to-idl-fur-astronomen">
German Translation</a>

<li> <a href="http://web-meister.ru/science/rukovodstvo-po-idl-dlya-astronomov">
Russian Translation</a>

</ul>

<p><br></p>

<hr size=3>

<h1 align=center><a name="int">  I.  INTRODUCTION </a> </h1> 

<hr>

<p><br></p>

Section I of this Guide is for those who are
unfamiliar with IDL or who are trying to decide whether to adopt it. 
Sections II and III are for users.  Although the examples are taken
from applications in astronomy, most of the Guide is general enough to be
useful to workers in medical imaging, geophysics, or other areas for
which IDL is well suited.</p>


<h2><a name="key"> 1.  Key Features of IDL </a> </h2>

<p><a href="#contents"> [Up to Contents]</a></p>

<p> The <b>Interactive Data Language (IDL)</b> is a proprietary software
system distributed by <em>Exelis Visual Information Solutions, Inc.</em> 
<a href="http://www.exelisvis.com">(http://www.exelisvis.com)</a>, originally
Research Systems, Inc.  IDL grew out of programs written for
analysis of data from NASA missions such as Mariner and the
International Ultraviolet Explorer.  It is therefore oriented toward
use by scientists and engineers in the analysis of one-, two-, or
three-dimensional data sets.  Exelis claims over 150,000 users.

<p>IDL is currently available in LINUX, UNIX/Solaris, Windows, and
Macintosh versions.  IDL device drivers are available for most standard
hardware (terminals, image displays, printers) for interactive display
of image or graphics data.  

<p> IDL is not simply a package of task-oriented routines in the style
of astronomical software systems such as IRAF or CIAO.  Instead, it is
genuinely a computer <b><em>language</em></b>, readily understandable
by any computer-literate user.  It offers all the power, versatility,
and programmability of high level languages like FORTRAN and C.  But it
incorporates three special capabilities that are essential for modern
data analysis: </p>

<ul>

<li> <b><em>interactivity</em></b>,</p>

<li> <b><em>graphics display</em></b>, and </p>

<li> <b><em> array-oriented operation</em></b>.  (IDL is
array-oriented in the sense that arrays can be referenced without the
use of subscripts or do-loops and that code is automatically
vectorized for fast array computations.)  
</ul>

<p>Users who are conversant with FORTRAN, C, C++, or other high level
languages will have little trouble understanding IDL.  Its syntax and
operation are clear, sensible, and convenient (most similar to
FORTRAN's).  Because it is interactive, learning IDL through on-line
trial-and-error is rapid. 

<p>IDL provides the scientist better understanding of and control over
computations and data analysis by virtue of a large number of special features:
</p>

<ul><ul>

<li> rapid response and iteration,<br>
<li> immediate access to all variables (stored in RAM),<br>
<li> immediate access to all source code (except Exelis-written
proprietary routines),<br>
<li> optimized array operations,<br>
<li> dynamic variable typing and memory allocation,<br>
<li> on-demand compilation and linking of routines,<br>
<li> versatile built-in plotting and graphics routines,<br>
<li> interactive session journal-keeping,<br>
<li> command recall/edit,<br><li> command scripts,<br>
<li> data structures, <br>
<li> flexible parameter specification in subroutine calls,<br>
<li> structured syntax, <br>
<li> full integration with windows systems, <br>
<li> support for all common scientific I/O protocols, <br>
<li> widgit (GUI) and object-oriented programming, and <br>
<li> a large suite of mathematical, data analysis, & special
     interactive utility routines.</p>

</ul>
</ul>


A functional description of IDL is available at <a
href="http://www.exelisvis.com/portals/0/pdfs/idl/IDL7_FuncSumm.pdf">
http://www.exelisvis.com/portals/0/pdfs/idl/IDL7_FuncSumm.pdf</a>.  More
history, background, and context may be found at <a
href="http://en.wikipedia.org/wiki/IDL_(programming_language)">
http://en.wikipedia.org/wiki/IDL_(programming_language)</a>.
A description of the IDL command-line environment as seen by the user is
given <a href="#back">below</a>.  </p>

Eight versions of IDL have appeared to date.  
<a href="http://www.exelisvis.com/ProductsServices/IDL/LatestRelease.aspx">Version 8.1</a> is
the latest.</p>

<p><br></p>


<h2><a name="context"> 2. IDL in Context </a>  
</h2> 

<p><a href="#contents"> [Up to Contents]</a></p>


What role does IDL play in the context of other software readily available to
astronomers?</p>


FORTRAN, C, or C++ cannot satisfactorily serve the need of individual
users for interactive data analysis because they do not provide a
standard interactive environment with supplied graphics
device-drivers.</p>

The data reduction and display software with which most astronomers are
familiar, including IRAF, STSDAS, AIPS, AIPS++, CIAO, MIDAS, and
SUPERMONGO, consists primarily of collections of specialized,
task-oriented routines.  They are interactive and graphics-oriented,
but they operate only in a pre-compiled form that offers the user
little opportunity for upgrade or customization.  Constituent routines
function like "black boxes" and do not provide the user with easily
understandable access to their inner workings.  These packages can be
executed from scripts, but they are not intended as the basis of
user-written applications.  They are complex enough that professional
programmers are required to maintain and enhance them.  They adjust
only slowly to user requirements.  By contrast, not only does IDL
offer greater transparency, versatility and efficiency, but also the
whole computer-literate user community may be drawn upon to extend and
improve IDL applications software.  </p>

<ul>

<li> For those tasks (e.g. CCD data reduction) where the large
astronomical reduction packages or stand-alone utilities such as
DAOPHOT or SExtractor offer powerful, reliable, and convenient
packages for standard astronomical applications, these are the systems
of choice.  IDL should not be thought of as an alternative there.
Rather it should be used as a means of bridging the gaps in those
packages and extending their capabilities.</p>

</ul>

Comparison with other popular systems: </p>

<ul>

<li> MATHEMATICA, MAPLE, or MATLAB provide powerful interactive
capability for mathematical computations and display.  The first two
of these also offer symbolic manipulation and equation-solving, which
IDL does not.  However, these systems are more oriented toward
mathematical analysis than data analysis.  They offer fewer
capabilities than IDL for image display and processing, and they are
less versatile for user-written programs and file I/O.  They offer
none of the specialized utilities needed by astronomers (e.g.  FITS
image and table file I/O, coordinate systems & astrometry, photometry
and spectroscopy packages, extinction laws and K-corrections,
databasing, etc.).  For an apples-to-apples comparison of these four
systems in a variety of applications, see the University of Colorado
Applied Math page <a href="http://amath.colorado.edu/computing/mmm/">
 (http://amath.colorado.edu/computing/mmm/)
</a>.  </p>

<li> SUPERMONGO and PGPLOT are widely used packages for making
graphical displays of previously-computed data.  IDL offers comparable
capabilities but in the context of a fully programmable, high-level
language, so that computation, data manipulation, and display are
simultaneously available.</p>

</ul>


<p>The intrinsic capabilities of IDL coupled with its extensive user
code libraries greatly enhance scientist efficiency. </p> 

<ul>

A new capability can be added using IDL in a small fraction of the
time it would take to do the equivalent programming in (inevitably
"blind") non-interactive languages or by trying to work around the
limitations of IRAF, MATLAB, etc.  Without leaving IDL, test data sets
can be created and displayed, and programs can be written, executed,
debugged, and revised with great efficiency. <b><em> IDL code can be
written in as little as one fifth the time of the equivalent FORTRAN
or C. </em></b></p>

The <b><em>built-in journal-keeping and command recall/edit
features</em></b> of IDL are so important to efficient and reliable
data analysis that it is something of a mystery why most other
astronomical software packages do not offer them.  </p>

<!-- 
    Compared to the inevitably "blind" programming with languages like
    FORTRAN or C, the interactive environment of IDL coupled with its
    <kbd>journal</kbd> and command recall/edit facilities is a
    <b>tremendously more efficient</b> way of writing reliable code.
    </p>

-->


</ul>



<p><br></p>

<h2><a name="pack"> 3. IDL Applications Packages </a>  
</h2> 

<p><a href="#contents"> [Up to Contents]</a></p>


<p>Because of IDL's versatility, transportability, and ease of
use, there is a <b><em>large, user-written, public library of
interactive IDL software, now over 10,000 programs.</em></b></p>

Many astronomy-oriented IDL routines and packages are
in the public domain.  </p>

<ul>

Early IDL packages were written at Goddard
Space Flight Center for analysis of images and two-dimensional spectra
in support of the International Ultraviolet Explorer, Astro, the
Hubble Space Telescope (GHRS and STIS), and other space missions.  </p>

Other packages have been written by groups associated with the Sloan
Digital Sky Survey, Chandra, ROSAT, COBE, Fermi, GRO, HST/NICMOS,
HST/ACS, SOHO, ISO, the Spitzer Space Telescope, the Green Bank
(Radio) Telescope, the Owens Valley Radio Observatory, the
Submillimeter Array, Los Alamos, Lawrence Livermore, and NRL, among
others.  There is also a large body of related remote-sensing,
medical, geophysics, and environmental research IDL software.  These
packages contain many programs of general interest (e.g. statistical
analysis, databasing) as well as specialized functions.  </p>

Unlike IRAF, STSDAS, and AIPS, there is no central distribution
point for "authorized" IDL software other than the Exelis-supplied intrinsic
IDL language.  However, neither does one have to depend on a small cadre
of expert programmers to fix bugs, explain program operation, or
provide new capabilities.  </p>

By virtue of publicly-available applications that cover the EM
spectrum from gamma-ray to radio wavelengths, <b><em>IDL has become the
nearest thing to a "universal" astronomical data analysis
system.</em></b> </p>

</ul>

<p> <b><em>The IDL source code for applications packages is automatically
available,</em></b> so the user can use the routines as written or,
alternatively, readily modify their components (as one would FORTRAN
subroutines) to customize them.

<p><b><em>IDL is ideally suited for software exchange over the
Web.</em></b> Because <b><em>no pre-compilation is required</em></b>,
installation of a new package, for instance, is simply a matter of
putting the ASCII source files in your IDL path.  

<p>IDL's cross-platform
design ensures that you can <b><em>confidently transfer code between
environments</em></b> (e.g. from a Solaris desktop to a Macintosh laptop).  

<p> C or FORTRAN programs can be executed from within IDL and
data exchanged between the systems. 

<p>For examples of IDL computational and graphical applications,
run the <kbd>idldemo</kbd> demonstration from the LINUX command line. 

<p><a href="#resources">See below for sources of IDL applications code.

<p><br></p>


<h2><a name="back"> 4. THE IDL ENVIRONMENT
</a></h2>

<p><a href="#contents"> [Up to Contents]</a></p>

Once you start IDL and begin typing at your console, you are
communicating with the main level of an arbitrarily large computer
program over which you have (nearly) complete control.</p>

<ul>

<li> As you type, each line is interpreted and immediately executed.
The commands you give are similar to those in a FORTRAN or C program,
the main difference being that each line must stand alone (you cannot,
for instance, loop back to an earlier command). </p>

<!--    [Native IDL does
not use the "parameter-set" control protocols familiar to
users of IRAF or CIAO; however, you could create IDL
programs that do employ such features.] 
 -->


<li> You can dynamically create, modify, or delete data elements.
Unlike FORTRAN and C, <u>you do not have to specify variable
characteristics in advance</u>.  <u>Memory expands as needed</u> to store new
variables.  All common types of elements possible in other languages
(e.g.  byte, integer, double-precision, floating point, strings,
logical; arrays from 1-D to 8-D; structures) are available.</p>

<li> You can command array operations <u>without reference to
subscripts</u> (e.g. <kbd>pix_3 = pix_1 + pix_2</kbd>), 
and the code will be <u>automatically vectorized</u> for fastest
execution.</p>

<li>  You have immediate access to: </p>

<ul>

<li> The full mathematical functionality of other
high-level languages like FORTRAN and C.</p>

<li>  A large set of utilities for
graphical displays on your computer terminal (images, plots, animations,
GUI's). </p>

<li> Utilities for file input/output in a wide variety of formats,
matched to standard printers and other auxiliary devices.  IDL
supports FITS as well as all standard image file formats (e.g. JPEG,
GIF, PNG); it also supports animations. </p>

<li> A large suite of powerful
mathematical tools.  For instance, most of the functionality of
<pub>Numerical Recipes</pub>  is available.</p>

<li> A large set of special functions
to help sense the instantaneous state of your programs, 
deal with processing errors, and otherwise
optimize the interactive computing environment.</p>

</ul>

<li> There is a sophisticated on-line help system.</p> 

<li> You can execute previously written files of commands in the form of
<u>"main programs" or "procedures" (subroutines)</u>. These can use the full
panoply of programming structures (loops, blocks, common blocks, etc.) of
other high level languages.</p>  

<li> With a single command, you can also execute
<u>"scripts"</u>---files which contain lists of commands similar to
those you would type in.</p>

<li> Scripts and procedures can easily be created by copying from your
interactive sessions, using the built-in IDL <kbd>journal</kbd> utility.</p>

<li> You can save the results of interactive computations at any time
during your session in a variety of forms, all suitable for input to
later IDL sessions or other software packages.  Instant, <u>format-free
preservation of data (and programs)</u> in your session is available
through the IDL <kbd>save</kbd> command.</p>

<li> You can execute IDL from a standard X-window (<u>"command-line" mode</u>)
or you can invoke a more elaborate GUI called the <u>"IDL Workbench"</u> that
offers a number of useful subwindows and mouse-driven shortcut commands.
If you wish, you can program your own GUI applications.</p>

</ul>

People who are familiar with IRAF, CIAO, or AIPS will
immediately recognize major new features in the IDL environment.</p>

<ul>

<li> Most calculations with those packages begin and end with data
stored as <b><em>files</em></b>, an artifact of the era when computers
had  limited random access memory capacity.  Most commands
therefore involve the use of cumbersome file names.</p>

<ul> 

By contrast, all active data in IDL are normally stored in
<b><em>random-access memory</em></b>, where one has immediate access
and can examine, manipulate, rename, or reconfigure them at will
<b>without file transfers</b>.</p>

This has the additional important advantages that IDL
programmers do not have to worry about file formatting of the results of
intermediate computations or consume mass memory to store them. </p>

</ul>

<li> IDL conveys a "hands-on" feel, and a corresponding confidence
that you know (or can find out) what is going on, that is
largely absent in these other systems.</p>

<li> Synthetic benchmark data sets can be quickly created
interactively for reality checks on program execution. </p>

<li> Subroutine parameters and "keywords" replace, in a more
streamlined way, the "parameter-set" files employed in IRAF-like
systems.  This increaes efficiency for experienced users, but the
absence of parameter input prompts may be troublesome for novices.</p>

<li> Using the built-in IDL <kbd>journal</kbd> utility, you
can maintain an <u>exact record</u> of your commands and IDL's
responses...making it more likely that your work is <u>actually
reproducible</u>.  </p>

<!--  Journal files are
an efficient basis for crafting scripts or procedure code.  -->

<li> Using the built-in IDL command recall/edit feature, it is trivial
to <u>iterate commands</u>, thereby reducing typos, facilitating exploration
of parameter space, and speeding repetitive tasks.</p>

<ul> This allows the quick, interactive creation of special-purpose
<u>"recall-based mini-scripts"</u> in lieu of writing external routines (e.g. for
graphics output). </p>

</ul>

<li> Unlike most other astronomy packages, which require extensive
pre-compilation and linkage of software components, new IDL programs
can <u>easily be incorporated</u> during your interactive session.</p>

<ul>
You can create a new capability in the form of a subroutine as quickly
as you can think and type and then <u>link it into your interactive
session with a single <kbd>.run</kbd> command</u>.</p>

Even novices will appreciate the ease with which accelerator commands
or scripts can be fashioned to speed routine tasks.  </p> </ul>

<li> Similarly, you can download and instantly begin using IDL
programs (in ASCII files) you find on the Web, so that you have
<u>immediate access to a huge, international library of scientific
software</u>.</p>

<li> You can modify the functioning of any user-supplied routine.
Although you cannot modify intrinsic IDL routines, you can easily
build "wrapper" programs for these that modify their default performance
or accelerate usage.  Your ability to <u>customize</u> computations is
enormously enhanced in IDL.  </p>

</ul>

IDL is oriented toward image analysis and signal processing, but by
comparison to IRAF, etc. it also opens a new dimension of capability
to make other kinds of important <u>numerical calculations</u> with great
efficiency and to create graphical or tabular representations of
them.  In this regard, it duplicates much of the functionality of
MATHEMATICA, MAPLE and MATLAB (though without symbolic manipulation).</p>

<ul>

Simple examples might include computing the volume element as a
function of redshift in different cosmologies, calculating line shapes
with simple radiative transfer methods and comparing to observed
spectra, doing quick Monte Carlo calculations, simulation of Malmquist
bias and other selection effects, generation of bremsstrahlung or
synchrotron spectra, and so forth.</p>

A great variety of such problems, for which (if they undertook a
careful computation at all) many astronomers would have written
stand-alone FORTRAN or C programs, can be handled with beautiful
efficiency by IDL and immediately incorporated with associated data
analysis tasks.  </p>

</ul>

<p>Basic IDL functionality has not changed for the last several
major releases.  Instead, additions have involved areas like
GUI support and object-oriented programming, which are directed
more at software developers than users interested in data analysis.</p>

<p><br></p>


<h2><a name="limits"> 5. IDL Limitations </h2>

<p><a href="#contents"> [Up to Contents]</a></p>

<p>IDL has many virtues, but what are its limitations?

<p>An obvious limitation, and a significant barrier for some people,
is that <u>IDL is a proprietary system</u>, which means that each site must
purchase an IDL license.  Some astronomers object on principle to
paying for software.</p>

<ul>

But, needless to say, you get what you pay for.  Even our ostensibly
"free" software packages like IRAF, CIAO, or AIPS++ carry a
<u>tremendous community price</u>, levied indirectly on us all.  The
purchase price of IDL must be weighed against the user effort
necessary to obtain the same level of performance by learning or
adapting a less capable system. </p>

My own view is that since the most expensive element of any
such system is <u>always</u> the scientist labor involved, the dollar
investment in IDL is clearly justified.  Current prices
are comparable to 1.5 months of a postdoc's salary, and for that you
get access to perhaps 1000 person-years of good,
astronomically-oriented software.  One would have to have a
<b><em>very</em></b> good postdoc not to consider IDL a bargain.</p>

</ul>

<p> IDL is an <b><em>interpreted</em></b> rather than a <b><em>compiled</em></b>
language.  This means that large IDL programs can execute less
rapidly than equivalent compiled programs written in FORTRAN or C.</p>

<ul>

However, this is also an important source of IDL's <u>efficiency</u>.
The main concern of working scientists in approaching software should
be how much of their <u>own time</u> elapses before they get a given
result.  Speed of execution is secondary, whereas the speed of coding,
configuring, and validating software is primary.  The software effort
of most scientists is not dominated by large-scale "pipeline"
computations or applications that are CPU- or memory-bounded.  It is
instead devoted to moderate-scale computations, interactive data
inspection and evaluation, comparison to theoretical models, special
cases not supported by large applications packages, production of
graphics for publications and talks, and so forth.  To complicate
matters, between their desktop, laptop, and/or lab computers,
astronomers now commonly deal with several different operating systems
on a daily basis. </p>

This environment places a premium on software <u>versatility,
convenience, transparency, modularity, and portability</u>---exactly
where IDL excels.</p>

The inherent vectorization of IDL's built-in software will often
compensate for its interpreted structure in competition with FORTRAN
or C programs that have not been properly optimized by their authors.  </p>

</ul>

<p> IDL works best on <u>moderate-sized data sets</u> (say up to 1 GB) and
where one does not need to reference individual array elements.  Users
needing to batch-process large amounts of data with more sophisticated
algorithms may find FORTRAN or C routines to be preferable.  However,
these can be linked into the IDL interactive environment and executed
from within IDL. 

<ul>

In fact, the combination of IDL as a "front-end" user interface with a
large suite of powerful, non-IDL number-crunching programs offers a
nearly ideal package:  computational efficiency together with
versatility and convenience in display/evaluation and a large
base of potential software developers.  </p>

</ul>

<p>Because of its optimization for interactive computing, IDL is not
the system of choice for large scale numerical computations (e.g.
hydrodynamical or N-body simulations).  However, it is valuable as a
medium to explore new computational approaches in a smaller setting
where raw speed is not important, and it is also excellent for
visualizing, analyzing, editing, and displaying numerical data sets
generated by simulation software.

<p>A problem for novices is that help with IDL may be hard to come by
at a new installation.  There are, however, consultants available at
Exelis, Web-based advice sites, large amounts of on-line or printed
documentation, and the examples of thousands of working IDL routines
in the public libraries that can help solve many software
difficulties.  

<!--  A key factor is that IDL's interactive
operating environment makes experimentation and debugging much easier
than is typical of data analysis software. 
-->


<p>Data reduction packages are not available in IDL for most of the
specific instrumentation available at the major observatories (e.g.
CCD mosaic imagery, multi-object spectrographs, echelle spectra,
etc.).

<ul>

For routine reduction of data from standard instrumentation, where the
needs of typical users have been accommodated through many
iterations, IRAF, STSDAS, AIPS, CIAO, and other existing packages are
entirely satisfactory.  Although IDL might offer a more friendly or
streamlined environment for experienced users, there is no compelling
reason to re-write in IDL the good packages that already exist in
other languages. </p>

It is the <u>data analysis</u> phase, as opposed to the
<u>reduction</u> phase, where the versatility of IDL is most useful.
The IDL Astronomy Users Library supports the standard data formats output
by the large astronomical reduction packages (including FITS image and
table files). </p> 

If you are a young observational astronomer, you have essentially no
choice but to become familiar with IRAF/STSDAS (UVOIR), AIPS (radio),
CIAO (X-ray), etc. because these provide the primary standardized data
reduction procedures in your field. The main decision, therefore, is
what <u>other</u> systems are most profitable to learn.  IDL is a
prime candidate.  </p>

</ul>

<p>Finally, the rapidly proliferating set of IDL applications routines
is both a strength and a weakness.  While one has access to a wide
variety of useful software, this is not always fully tested since the
authors typically apply it to problems of limited scope.  The hardest
part of using IDL often is determining what routines are available for
a given application and deciding which is best to use.  

<p>Overall, in exchange for its improved versatility and power, <b><em>IDL
requires a higher level of computer skill</em></b> than do systems like
IRAF, AIPS, or CIAO. </p>

<ul>

The IDL user must take greater responsibility for the reliability of
the results.  On the other hand, IDL's interactive environment offers
much more robust and efficient trial-and-error exploration of program
function on real or synthetic datasets than is available in typical
data analysis packages.  It is much easier to diagnose difficulties
and validate the proper execution of software in IDL.

</ul>

<p>On balance, IDL is an invaluable tool for most observational or
theoretical astronomers.

<p><br></p>


<h2><a name="resources">6.  DEMOS, TUTORIALS, SOFTWARE LIST
</a></h2>

<p><a href="#contents"> [Up to Contents]</a></p>


<b>Resources</b>: For lists of important astronomy-oriented IDL
resources (guides, help files, demos, tutorials, software) other than
those packaged with the Exelis distribution, see:</p>

<ul> 

<li><a
href="astro-dept-idlresources.html">
My IDL Resources page</a></p>

<li><a href="http://idlastro.gsfc.nasa.gov/other_url.html">The IDL Astronomy
User's Library Resources page</a></p>

</ul>

<b>Demonstrations:</b> To get a feel for what IDL can do, try running
the package of <b>standard IDL demos</b> supplied by Exelis.  Start
from the LINUX prompt (within an X-window) and type
<kbd>idldemo</kbd>.  </p>

<b>Tutorials</b>:  A set of three introductory <a
href="../IDLexercises/index.html"><b>IDL
exercises</b></a> which introduce its basic features is available on
the UVa ASTR 511 home page.  Other sites offering IDL tutorials are
linked to the <a
href="http://idlastro.gsfc.nasa.gov/other_url.html">Astronomy User's
Library</a>.</p>

</ul>


<p><b>Software List: </b> Six different levels of IDL
code will be useful to you:  </p>
 
<ul>

<li> <b>Intrinsic IDL</b>: written by Exelis and described in the
	   IDL manuals and online help system invoked by the
	   <kbd>?</kbd> command.  Intrinsic IDL code is proprietary.
	   At UVa, intrinsic IDL is maintained by ITS on an
	   all-University server.  50 users can have simultaneous
	   access.  Information on the UVa installation is available
	   <a href="http://www.its.virginia.edu/research/idl/">
	   here.</a> </p>

<li> <b> The IDL User's Library: </b>routines of general interest
	   (statistics, image conversion, etc.) verified and
	   maintained by Exelis but non-proprietary.  Packaged as
	   part of the standard IDL distribution.  By default, these
           are located in the directory <kbd>$IDL_DIR/lib</kbd>.  </p>

<li> <b> The IDL Astronomy User's Library:</b> a large set of routines
	   suitable for data analysis, image processing,
	   and databasing, largely written by scientists at Goddard
	   Space Flight Center.  Contains many applications of wide interest
           as well as specialized astronomical routines.
           Usually well documented internally
	   and well verified in standard applications.  Updates typically occur
	   several times per year.  Assumes IDL v6.1 or
	   higher. Code and other documentation are available through
	   an Internet browser or FTP from <a
	   href="http://idlastro.gsfc.nasa.gov">
	   http://idlastro.gsfc.nasa.gov.</a> A <a
	   href="http://idlastro.gsfc.nasa.gov/contents.html">
	   functional listing </a> is available from the AstUseLib
	   site.  Updates are listed in reverse chronological order in
	   a <a href="http://idlastro.gsfc.nasa.gov/news.html">news
	   file</a>.  At UVa, the AstUseLib routines are stored in
	   <kbd>/astro/idl/Astrolib</kbd>.</p>


<li> <b> MOUSSE (Multi-Option UIT Software System Environment):</b> a
	   set of routines largely written by the Ultraviolet Imaging
	   Telescope team at GSFC.  Those routines which were not
           transferred to the AstUseLib but which remain useful
           can be obtained (individually or as a tar file) from:  
            <a href="../IDLexercises/minimousse">
            https://rwoconne.github.io/rwoclass/astr511/IDLexercises/minimousse</a>. 

        <!--  href="http://idlastro.gsfc.nasa.gov/ftp/contrib/landsman/mousse/">
	   http://idlastro.gsfc.nasa.gov/ftp/contrib/landsman/mousse/
	   </a>.  -->

           A file listing MOUSSE routines as of 1996 (including
	   those later transferred to the AstUseLib), sorted by
	   function, is given in <a
	   href="mousserou-063097.pdf">
	   "Current MOUSSE Software"</a>.  
           </p>
         

<!-- 
   If you want a full set of the MOUSSE routines, a gzipped
   TAR file containing the most recent versions (through
   2001) is available <a
   href="mousse-july01.tar.gz">here</a>. 
   (Note: the STScI MAST archive distributes an <em>older</em>
   version of MOUSSE, ca. 1993, from <a
   href="http://archive.stsci.edu/uit/analysis.html">
   http://archive.stsci.edu/uit/analysis.html</a>.  That has
   been superseded by the versions in the TAR file.)</p>

   Some MOUSSE routines employ special common blocks to track
   image displays, etc., so MOUSSE requires that a special
   "startup" file be executed (<a href="#startex">see
   below</a>).  MOUSSE routines are self-documented.  Older
   routines have not been updated since 1996 and may exhibit
   incompatibilities with more recent IDL releases, new data
   formats, and so forth.  Let me know if you encounter such
   difficulties.  At UVa, Mousse software is stored in
   <kbd>/astro/idl/Mousse</kbd>.</p>

-->


<li> <b>Software from the Worldwide IDL User Community:</b> The
AstUseLib provides a large set of <a
href="http://idlastro.gsfc.nasa.gov/other_url.html">links</a> to other
sites distributing useful IDL software.  </p>

<li> <b> Personal routines</b>, written by you.  IDL users quickly
	   discover the advantages of writing their own IDL code even
	   if they never progress beyond scripts, simple accelerator
	   routines, or customized versions of user library programs.
	   It is convenient, though not essential, to keep all such
	   routines in one directory.  In this document, we refer to
	   this directory as your <b>"idl directory."</b> The UVa
	   system default IDL environment file assumes that the
	   directory will be named, or aliased to, <b><em>idl</em></b>
	   under your home directory.</p>
           
</ul>

<p><b>Acknowledgements:</b> In any published work utilizing IDL
     software written by others, you should acknowledge the author.
     If you use the Goddard software, the GSFC Astronomy User's
     Library group and curator Wayne Landsman should be acknowledged.
     Modified versions of others' software should propagate the
     authorship list in the header section of each routine.</p>

<p><br></p>


<hr>


<h1 align=center> <a name="guide">II.  
GUIDE TO IMAGE PROCESSING<br> WITH  IDL </a>  </h1>

<hr>

<p><a href="#contents"> [Up to Contents]</a> </p>

<p> This section provides an introduction to intrinsic IDL and
user-supplied applications routines frequently used in 2-D image
processing and related kinds of data evaluation and computation.  Only
the most common options for each command are listed.</p>

<b><em>Assumed:</p>

<ul>
<li>  IDL V6.1 or higher in a LINUX workstation
or MAC OS-X environment.  </p>

<li> All descriptions below are for the command-line IDL environment
and the basic "direct graphics" mode executed from within
<em>X-windows</em>.  See <a href="#windows">"X-Windows Notes"</a> at
end of the writeup.  </p>

<!-- NOTE!  IDL v7.0 (earlier?) does _not_ support command-line
operation on Windows computers, only UNIX-based machines!  -->

<li> Unless noted, all non-intrinsic routines listed below are from
the Astronomy Users Library.  </p>

</ul>

</em></b>

<p> This guide is oriented toward the UVa/LINUX installation of
IDL.  However, I have tried to clearly distinguish details which
are specific to the local system so that others will be able to
use the guide.  

<p><br></p>

<hr>


<h2 align=center> <a name="start">1.  STARTING & STOPPING IDL </a>
</h2>

<p><a href="#contents"> [Up to Contents]</a></p>


<li><b>To enter IDL</b>: type <kbd>idl</kbd> at the LINUX prompt from
     within an X-window.
     This starts an IDL session running in "command-line mode" in the
     terminal window from which it was called.  I recommend that
     IDL novices plan to learn the basics in this environment, although
     they should certainly explore the alternatives listed next.</p>

<ul>

<li> In Versions 5 and 6 you can instead use a graphical interface,
     the "IDL Development Environment."  To enter that, type
     <kbd>idlde.</kbd> IDLDE offers a number of convenience features
     for the experienced user.</p>

<li> As of Version 7, a more elaborate graphical interface called the
"IDL Workbench" has replaced the Development Environment.  Again, to
invoke the Workbench,
enter <kbd>idlde</kbd>.  <a href="IDL_Workbench_screenshot.jpg">
Here</a> is a screenshot of an IDL Workbench session.  If you want to
explore the Workbench approach, try the exercises suggested in Chapter
2 of the version 7 <pub>Getting Started</pub> manual.  </p>

<li> Another alternative is to
  use <a href="http://idlwave.org/">IDLWAVE</a> This is an integrated
  editor/IDL execution facility based on GNU Emacs.  The many powerful
  convenience features in IDLWAVE are useful mainly to experienced IDL
  programmers.  <a href="http://idlwave.org/screenshots/screen_5.0.png">Here</a>
  is a screenshot of an IDLWAVE session.</p>


<li> The descriptions below are for the command-line environment
     invoked by the <kbd>idl</kbd> command and employ "direct
     graphics" commands (as distinct from the "object-oriented
     graphics" used to create GUI displays).  However, the basic
     commands entered during an interactive session are the same for
     all environments (e.g. in the Workbench you would enter these in
     the Command Line window opposite the <kbd>IDL></kbd> prompt).  </p>

</ul>

<li><b>Troubleshooting at Startup</b> </p>

<ul>
    
  <li> If you get messages complaining about the "license server" or
     stating that you have been shifted into the "7 minute demo mode,"
     then there is a problem with the <b>licensing software</b> that
     authorizes individual users to access the IDL executables.  This
     may be because too many users (at UVa, more than 50) are trying
     to access IDL (in which case, you just have to wait).
     Alternatively, there may have been a failure in the license
     daemon which authorizes you to link to the IDL source code.  You
     will need systems-level help to address the latter difficulties.
     At UVa, IDL source code is maintained by ITS
     in directories under  <kbd>/common/rsi</kbd>.</p>

  <li> If you cannot access IDL itself or certain routines within IDL,
       check to be sure you have <b>defined all the necessary shell
       variables and aliases</b> to point properly to the various IDL
       directories.  See the <a href="#setup">"Setup"</a> section at
       the end of this writeup.</p>

      <ul>

       <b>An incorrect path setup is one of the most common sources of
       problems in IDL sessions.</b> </p>

       To configure your session on the main UVa Astronomy LINUX server,
       you must first
       <kbd>source</kbd> the standard setup
       file <kbd>/astro/idl/idl_env.csh</kbd>.  You can do this
       manually or modify your <kbd>.cshrc</kbd> file to do it
       automatically.  This will set you up to run the latest version
       of IDL with proper links to all current software directories,
       including the Astronomy User's Library, MOUSSE, and ATV. </p>

   </ul>

 <li> If the windows environment does not respond properly, check to
      be sure you are <b>running X-windows</b> and that the windows
      parameters have been properly set for the kind of visual display
      environment you intend to use (e.g. 8-bit pseudocolor, 24-bit
      truecolor, etc).  The LINUX terminal command <kbd>xdpyinfo</kbd>
      will list the supported modes for your display.  The IDL command
      <kbd>help,/dev</kbd> will list the current properties of your
      display assumed by IDL.  For more details, see the <a
      href="#display">Image Display</a> section below.</p>
       
  <li> If you have trouble with the colors on your terminal changing or
     "flashing" when you move the cursor during an IDL session, see
      the <a href="#display">Image Display</a> section below.</p>

  <li> Your personal "idl directory", if you have one, will not be
     accessible unless it is the current directory OR it is included
     in the <kbd>IDL_PATH</kbd> shell environment variable.  At UVa,
     this will be automatic if the directory is in your root directory
     and is named, or aliased to, <em><b>"idl"</b></em>.  (See the <a
     href="#envex">environment setup file example</a> below.) </p>
 
</ul>


<li><b>To customize the IDL environment</b>, you can
    execute any number of special instructions at the start of each
    session. </p>

<ul>  

    IDL will always execute the special "Startup" file
    defined in the <kbd>$IDL_STARTUP</kbd> environment variable.  A
    standard version of this file must be executed before the MOUSSE
    routines will run properly.  This is done by default for UVa
    Astronomy users.  See the <a href="#setup">"Setup"</a> section
    below.  You can modify the startup file as you like (e.g. to open
    special plotting windows or to establish main-level common
    blocks).  </p>

    You can also execute personal startup files to further customize
    your session.  These are usually <em>batch</em> files (see <a
    href="#prog">"Program Execution"</a> below), executed by typing
    <kbd>@[filename]</kbd>.  </p>

</ul>

<li><b>To give LINUX system commands from within IDL:</b> enter
     <kbd>$</kbd> as the first character on the command line</dd></p>

<li><b>To interrupt and resume IDL</b>:  use the standard <kbd>^z</kbd> and 
   <kbd>fg</kbd> LINUX commands.</p>

<li><b>To interrupt an IDL routine:</b> type <kbd>^c</kbd>.  To
   continue the same routine, type <kbd>.con</kbd>.  To exit the
   routine after an interrupt and return to the main level, type
   <kbd>retall</kbd>.</p>

<ul> If you are in cursor mode, you may have to move the cursor to the
   active window and press mouse buttons to complete the interrupt.
   On some commands (e.g. array calculations or I/O) an interrupt may
   require some time to take effect. </p> 
</ul>


<a name="recall"><li><b>To repeat or edit and execute an earlier command:</b></a></p>

<ul> During an interactive session, your command line entries are
   stored in a <b>command recall buffer</b> (as in LINUX
   <kbd>tcsh</kbd>).  You can use the "up arrow" ("down arrow") keys
   to move backwards (forwards) through the command buffer to recall
   or edit commands.  Use EMACS-like editing commands.
   The default for the command buffer length
   is 20 commands.  (It is useful to set this to a higher
   number by defining the system variable <kbd>!EDIT_INPUT=100</kbd>
   in the startup file.  This is done by default in the MOUSSE startup
   files.) Recall/edit is an exceptionally useful means of iteration
   during an IDL session.</p>

   In editing, be careful not to give the <kbd>^d</kbd> command on an
   empty line, since this will terminate your session!</p>

</ul>

<li><b>To continue a long statement on the following line:</b> end the line with
   a dollar sign (<kbd>$</kbd>).  You may do this anywhere in the line where a
   space would be allowed except within a string variable. <p>

<li><b> To give multiple commands on a single line</b>: separate them
   with the ampersand (<kbd>&</kbd>).  E.g.:</p>

<ul>

    <kbd> x = a+b   & y = sqrt(x)  </kbd> </p>

  <!--    <kbd>find=where(x gt 100, count) & print,count</kbd>.</p>
  -->
  

   A set of <kbd>&</kbd>-linked commands on a single line
   constitute a <b>"micro-program"</b> which can be executed, then edited and
   re-executed with a couple of keystrokes.</p>

</ul>

<li><b>To leave IDL:</b> type <kbd>exit</kbd> or <kbd>^d</kbd>.
     <b><em><u>All windows and data in RAM will be
     flushed.</u></em></b> If you want to save data, use the
     <kbd>save</kbd> command or various other file writing commands
     <b>before</b> exiting.</p>

</ul>

<p><br></p>  <p><br></p>

<hr>

<h2 align=center> <a name="help"> 2. HELP </a> </h2>

<p><a href="#contents"> [Up to Contents]</a></p>

<u><b>Exelis Documentation</b></u></p>

<ul>

IDL is thoroughly documented in electronic manuals.  Exelis issues a
full set of manuals in PDF format with each license.  If the PDF
versions have been installed on your computer system, they can be
accessed through the LINUX command <kbd>idlman</kbd>.  The most
important manuals are <pub>Using IDL, The IDL
HandiGuide/Quick Reference, Building IDL Applications/Application
Programming, </pub> and <pub>The IDL Reference
Guide</pub>.  These are accessible on-line from within an IDL
session through a Hyperhelp facility.  (Note: the titles of some
manuals have changed with version number.)  </p>

<!--   The V.5 on-line hyper-linked help facility (see below) is good, if
less comprehensive than the full manuals.    -->

<ul>

The introductory IDL guide is called <a
href="getting-started-IDL-v7.0.pdf">
<em>Getting Started with IDL</em></a>---click for a PDF version.  The
printed versions of the older <pub>IDL
Basics</pub> manual for V3 and V4 take you through a number of
interesting sample applications and provide helpful hints.</p>

The best way to remind yourself quickly of the operation of intrinsic
IDL routines is to refer to
the <a href="IDL-quickref-v7.0.pdf"><em>IDL Quick Reference</em></a>.
Unfortunately, this "quick" guide has become rather unwieldy, and, at
least for a reference on basic IDL functionality, it may be easier to
use one of the older versions of
the <a href="IDL-handiguide-v5.4.pdf">
<em>IDL HandiGuide</em></a>.    </p>

You will probably find it helpful to make a hardcopy of the <pub>Quick
Reference</pub> or <pub>HandiGuide</pub> sections titled
"Functional List," "Syntax," "Statements," "Executive Commands,",
"Special Characters," "Subscripts," "Operators," "System Variables,"
and "Graphics Information."  That will total only about 30 pages.  </p>
 
</ul>

<b>Browser Access to Documentation:</b></p>

<ul>

<!-- Exelis link changed to l3harris, 12/19/20 --> 

<li><a href="https://www.l3harrisgeospatial.com/docs/using_idl_home.html">IDL
Documentation Distribution Site</a></p>

<li> To access documentation for IDL_5.1 in HTML using a Web browser, 
<a
href="idl_5.1_html/idl.htm">
click here.</a> and bookmark the page.</p>

<li> <a href="http://idlastro.gsfc.nasa.gov/idl_html_help/home.html">IDL Astronomy
User's Library Copy of IDL 6.4 Documentation</a></p>

<!--  Gone 2009: Another source for IDL PDF documentation: <a
href="http://gradea.uci.edu/idl-docs/onlguide.pdf">IDL Online Guide
(UCI)</a></p>  -->

</ul>
</ul>

<u><b>Other IDL Help Resources</b></u>:</p>

<ul>

<li>
<a
href="astro-dept-idlresources.html">
My IDL Resources page</a></p>

<li><a href="http://idlastro.gsfc.nasa.gov/other_url.html">The IDL Astronomy
User's Library Resources page</a></p>

<li> <a href="http://groups.google.com/groups?q=group%3Acomp.lang.idl-pvwave"> 
The comp.lang.idl-pvwave newsgroup</a></p>

<li> 
<a href="http://www.dfanning.com/documents/tips.html">Coyote's Guide to
IDL Programming (David Fanning)
</a></p>

<li><a href="idl-syntx-sterner.html">Ray
Sterner's Quick Guide to IDL Syntax</a></p>


</ul>


<u><b>Determining IDL Version Number</b></u></p>

<ul>

<li> At the LINUX prompt, type <kbd>idl</kbd>; the version number is
displayed on your terminal at the beginning of each IDL session.</p>

<li> Or: check the directory to which the LINUX shell variable
<kbd>$IDL_DIR</kbd> points.</p>

<li> Or: within an IDL session, type <kbd>print,!version</kbd> or
<kbd>help,!version,/str</kbd> to display the information on the version
and assumed operating system stored in the system variable
<kbd>!version</kbd>.</p> 

</ul>

<u><b>Learn by Example</b></u></p>

<ul>

One of the best ways to learn how to
write and use IDL programs is simply to <b>inspect existing IDL
programs</b> in the AstUseLib directories.  You can
<kbd>more</kbd> them in LINUX, or use the AstUseLib <kbd>getpro</kbd> routine to
copy them to your local directory.  To view public routines during an IDL
session, type <kbd>.run -t [routine name]</kbd>.</p>

</ul>

<u><b>Informational Commands</b></u></p>

<ul>

<li> <kbd>idlhelp</kbd> or <kbd>idlman</kbd>: given from the LINUX
    prompt, these commands open the PDF versions of the standard IDL
    manuals (if they are loaded on your system).</p>

<li><kbd>?</kbd> : given from within IDL, this invokes the IDL
    HyperHelp facility.  Click on the "Index" tab for a list of all
    entries (lists general discussions as well as individual routines,
    the latter listed in all-caps).  </p>

    <!-- (Warning: several versions of IDL,
    e.g. 6.0, employed a more awkward PDF-based help facility.  If you
    are saddled with this, it's better to upgrade.)   -->

<li><kbd>?[command]</kbd> :  provides HyperHelp information on the given
    intrinsic IDL command.  Does not work for user-supplied routines.
    Note:  no space or quote mark between <kbd>?</kbd> and name.
    </p>

<li><kbd>[command without arguments]</kbd> : Most AstUseLib and other
    user-supplied procedures are coded such that if you enter the <em>name</em>
    of the routine without arguments, a list of expected arguments is
    printed on your screen.  Does not work for intrinsic IDL routines
    (but see <kbd>help,/rou</kbd> below).  Does not work on most
    functions (as opposed to procedures). </p>

<ul>

    This is a useful convention to code into
    your own programs.  Use the <kbd>n_params</kbd> function to sense
    the absence of input parameters, as in the following:</p>

  <pre>
  <kbd>if (n_params(0) eq 0) then begin
         print,'CALLING SEQUENCE: program_name,var1,var2,var3'
         return
       endif
  </kbd></pre></p>

</ul>

<!--  <li><kbd>man</kbd>:  The <kbd>man</kbd> command <u>without arguments</u>
    produces a graphics menu display similar to that generated by
    <kbd>?</kbd> but which provides information on AstUseLib, MOUSSE,
    and other user-written routines.  <kbd>man</kbd> is MOUSSE program
    written by Wayne Landsman and is available at: 
    <a href="http://idlastro.gsfc.nasa.gov/ftp/contrib/landsman/help/">
    http://idlastro.gsfc.nasa.gov/ftp/contrib/landsman/help/</a>.</p>

  <ul>
    Note: the topics included are only those
    "pro" files which have been parsed by a special documentation
    extraction routine (<kbd>mk_library_help</kbd>) and placed in a special
    help directory.  This is usually done by the person who maintains
    your IDL system.  </p>
</ul>

-->

<li><kbd>man,[command-name-string]</kbd>:  The MOUSSE 
    <kbd>man</kbd> command will print the
    information header of the named routine in your IDL command window.  It
    works on any properly formatted IDL routine in the
    <kbd>IDL_PATH</kbd>.  For instance, if you want information on the
    AstUseLib FITS_READ command, you would type:</p>

    <p align=center>  <kbd>man,'fits_read</kbd> </p>

<ul>

    Note that the argument of <kbd>man</kbd> must be an IDL
    <em>string</em>---i.e. it must be quoted (but the trailing quote
    mark can be omitted).  Do not enter the <kbd>.pro</kbd> suffix
    for the filename.  </p>

    The <kbd>man</kbd> function operates by finding the first file
    with the name <kbd>"[command].pro"</kbd> in the
    <kbd>IDL_PATH</kbd> and listing all those lines in the file
    between the two lines starting with ";+" and ";-" in the first two
    columns.  
    It is <b>strongly recommended</b> that you place headers
    of this type in your own *.pro routines.  There is a standard
    internal header format adopted by most IDL coders, though you do not have
    to follow this in your own routines.  </p>

    Unfortunately, intrinsic IDL routines cannot be accessed by <kbd>man</kbd>.</p>

<!--     The IDL Users Library routine <kbd>doc_library,[command-name-string]</kbd>
    has similar functionality; it also lists the directory path to the file. </p>
-->


</ul>

<li><kbd>$more [directory/command.pro]</kbd> :  lists any local program.
    You could define LINUX shell variables named <kbd>$ATV_DIR,
    $ASTUSE_LIB,</kbd> etc, to point to the appropriate directories to
    avoid having to remember which these are.  </p>

<li><kbd>getpro,[command]</kbd> : writes a copy of any non-proprietary
    procedure file to the current directory.  Does not work on
    intrinsic IDL software.  You can display or edit the procedure to
    modify its function as desired.  If you do not alter the name, and
    place it in the IDL path ahead of its original location, then your
    version will be compiled and executed instead of the nominal one.
    It may be <b>safer to change the name</b> <em>(<u>both</u> the file name
    <u>and</u> the procedure name within the file)</em> to prevent
    inadvertent errors.  

<ul>

    <p>Note:  one deficiency of current user-supplied procedure
    documentation is that the dependencies (routines called by a given
    procedure) are not listed.  If you use <kbd>getpro</kbd> to obtain
    and edit a supplied routine to behave differently, this may have
    unintended consequences for the functioning of other procedures.
    One method of looking for such interactions would be to
    <kbd>grep</kbd> the ASCII files in the library directories for
    other references to the routine you intend to change.  A quick way
    to identify what subroutines are called by a given program is to
    <kbd>.run</kbd> the program as the first step in an IDL session.
    Each subroutine is listed on the screen as it is compiled.  </p>

</ul>



<li><kbd>.run -t [command]</kbd> : an alternative way of obtaining a
   listing of a routine.  This will compile [command.pro] and
   simultaneously send a listing to the screen with line numbers
   appended (same numbers as printed in IDL error statements, so is
   useful for debugging).  To save the listing in a file, use the
   form:  <kbd>.run -l (filename) [command]</kbd>.  (Warning: if you
   mistakenly omit the filename here, you may start overwriting
   the [command] file if it is in your current directory.)</p>

<li><kbd>print,[variable(s)]</kbd>:  display the value of any active variable(s)
on your terminal.  Works for any variable type, but beware in the
case of large arrays(!) </p>

<ul>

    Formatting: row vectors are printed across the
    screen, column vectors are printed down the screen.</p>

    Use the <kbd>printf</kbd> command to send the output to a selected
    file or other external unit.  </p>

</ul>


<li><kbd>help</kbd> : lists all active variables, their characteristics,
    compiled programs, information on storage areas, etc.; various
    options.   But <b>does <u>not</u> explain</b> commands.  There are many
    optional keywords for use with <kbd>help</kbd>. Examples are given
    below.  To get a full list, type <kbd>?help</kbd>.  </p>

<ul>

<li><kbd>help,/rou</kbd> : prints argument list for all compiled routines
(other than intrinsic IDL routines).  Lists procedures and functions
separately.  </p>

<li><kbd>help,/sy</kbd> : prints current values of all "system variables", which are
    special variables known to all routines.  Names of these begin
    with a "!", e.g. <kbd>!dir, !path,</kbd> etc. </p>

<li><kbd>help,/rec</kbd> : prints contents of command recall buffer in reverse order</p>

<li><kbd>help,/dev</kbd> : prints parameter settings for current graphics device</p> 

<li><kbd>help,/mem</kbd> : lists current memory usage</p>

<!--  <li><kbd>help,/pro</kbd> and <kbd>help,/func</kbd>: lists names and
parameters for compiled procedures or functions, respectively (other
than intrinsic IDL routines)</p/>  -->


</ul>


<li><kbd>print,!d</kbd> or <kbd>print,!p</kbd> :  print the system
    variables that control the device display and the plotting
    environment, respectively.  See the IDL manuals for details.</p>


<li><kbd>print,!path</kbd> : print the current path list of directories
    searched for *.pro routines.  Since many instances of failed or
    missing software occur because your path is incorrectly set, it is
    useful to remember to check <kbd>!path</kbd> if you run into
    trouble.  If the <kbd>!path</kbd> string is too long to print, use
    the <kbd>strmid</kbd> routine to make and print extractions from
    it.  </p>

<li><kbd>$printenv</kbd> : will list all default shell parameters, including the
    IDL directory defaults, if defined.</p>

<!--
<li><kbd>tvstatus</kbd> : a MOUSSE routine that lists properties of
active windows</p>
-->

<a name="journal"><li><kbd>journal,[filename]</kbd>:</a>
    Starts the <kbd>journal</kbd> utility, which
    <b>records in a file all entries you make <u><em>and</em></u> most
    IDL responses</b>.  Certain responses (e.g. to <kbd>help</kbd>) are not
    recorded to prevent cluttering up the file. </p>

<!-- Some user routines
    also disable journal output. </p>
-->


<ul>

    Any text you enter on a given line <em>preceded by a
    semicolon</em> will be <em>ignored by the compiler</em> and
    included in the journal file as a comment---so you can <b>annotate your
    session interactively</b> to your heart's content. </p>

    Your journal file will be written and closed when you type
    <kbd>journal</kbd> again or <kbd>exit</kbd> your IDL session.
  </p>

    <b>It is hard to exaggerate the value of keeping IDL journal files
    for serious work.</b>  It is good practice always to use a journal
    file so that you can check or reproduce what you have done,
    recover errors, and so forth.  If you edit out the blunders and
    undesirable clutter of your journal files, you will have a handy
    running record of your work.</p>

    Journal files permit rapid re-creation of an IDL session, in whole
    or part, or (if the activity was worth saving and repeating) can
    be edited into the form of a main program, subroutine, or script.
    </p>

     <em>Warning:</em> the <kbd>journal</kbd> routine will overwrite
    an existing file with the given <kbd>[filename]</kbd> without
    warning.  <em>Use unique names</em> for each session.  Also, the journal
    file may be lost in the case of an IDL crash or a system failure
    (e.g. power outage).  For long sessions, you may want to plan for
    more than one journal file.  </p>

</ul>
</ul>

<hr>

<h2 align=center> <a name="prog"> 3. PROGRAM EXECUTION </a> </h2>

<p><a href="#contents"> [Up to Contents]</a></p>

All intrinsic IDL programs are <b>compiled and ready for execution when
you begin your session</b>.  Other programs are normally compiled only
when you request them.  A list of all compiled non-intrinsic routines is
presented if you type <kbd>help,/rou</kbd>.  </p>

<b><p>NOTE</b>:  all IDL main programs, subroutines ("procedures"),
       and functions are assumed to be in files with the
       <b><em>explicit extension '.pro'.</em></b> </p> 


<u><b>Variables</b></u></p>

<ul>

Creating:</p>

<ul>

To create or modify variables, <b>simply use them in an assignment
   statement</b>.  Memory for each is automatically set aside and expands
   indefinitely.  <b>No pre-declaration of variables is necessary</b>.  The type
   of a new variable is inferred from the context. For
   details on types of variables in IDL, see "Part II:  Components of
   the IDL Language" in the <pub>Application
   Programming</pub> manual.  E.g.:</p>

<ul>

     <kbd>z = 1.0e-3</kbd> creates a floating point scalar<br>
     <kbd>c = 3.0d10</kbd> creates a double-precision floating point scalar<br>
     <kbd> a = [1,2,3] & a = [a,4,5]</kbd> creates and then expands an integer vector</p>

     <kbd>testdata = fltarr(512,256)</kbd> creates a 512x256 2-D floating point 
          array with zero entries.</p>

        <ul> This array will be 512 elements wide (# of columns) and
	  256 elements high (# of rows).  Note that this column/row
	  assignment convention is <b><em>reversed</em></b> from FORTRAN and normal
	  matrix notation but that it corresponds to normal
	  <em>f(x,y)</em> graphical notation.  IDL arrays are <u>stored
	  with the first index changing fastest</u>.  This allows faster
	  display of images because the elements on each
	  horizontal scan line are stored contiguously.</p>

          Note also that (again to conform to graphical standards) the
	  first element of any IDL vector or array is <b>always at index
	  0 not 1</b>.  For example, in the array
	  <kbd>z=[20,30,40,50]</kbd>, <kbd>z[0]=20</kbd>, and
	  <kbd>z[3]=50</kbd>.  But <kbd>z[4]</kbd> is undefined. </p>

        </ul>

     <kbd>testdata = findgen(512,256)</kbd> creates a 512x256 2-D floating point
          array with each element set to the value of its 1-D
          subscript (starting at 0).  Thus, testdata(100,0) = 100.0 while
          testdata(0,100) = 51200.0. </p>
 
     <kbd>name = "Maxwell"</kbd> creates a string </p>

<ul>
   If you need to create a long string (e.g. in format statements),
   you can define pieces of the string on separate lines and then
   concatenate them.  (E.g. <kbd>stringtot =
   string1+string2</kbd>).</p>
</ul>

     <b>"Structures"</b> in IDL are sets of other variables (an arbitrary
     mixture) that can be referred to by a single name.  They can be
     very useful in data analysis problems.</p>

<!-- ADD an example of a structure here --> 

 </ul>

   The <kbd>help</kbd> command gives you a listing of active variables
   and their properties.</p>

</ul>

Deleting: </p>

<ul>

To delete variables (e.g. when you have too much memory
   in use), use <kbd>delvar</kbd>.  You can overwrite the contents
   of any variable simply by using an assignment statement.
   A fast way to flush arrays is simply to set them equal to a scalar
   (e.g. <kbd>a=0</kbd>).  If you use a lot
   of files, it is also good to prevent file quota errors by
   occasionally giving a <kbd>close,/all</kbd> command.  </p>

</ul>

System variables:  </p>

<ul> These are special variables, with names prefaced by <kbd>!</kbd>
(e.g.  <kbd>!help_path</kbd>), that are <b>universally known to all IDL
routines</b>.  About 30 of these are pre-defined and assist with various
aspects of program operation, mainly graphics output.  You can create
your own system variables using the <kbd>defsysv</kbd> command.  You
can change the value of system variables (except "read-only"
variables) using assignment statements.  To see the current values of
all system variables, type <kbd>help,/sy</kbd>.</p>

<!-- ADD: examples of the more useful sysvar  -->

</ul> </ul>


<u><b>Mathematical Operators and Functions</b></u></p>

<ul>

IDL supports a full set of arithmetic, relational, logical, min/max, and matrix
operators.  Among others: </p>

<ul>

  <kbd> &nbsp; +   -   *   /  ^  ++ --  MOD  > IF THEN NOT AND EQ GE LT # ...</kbd>, etc</p>


See <pub>Building IDL Applications/Application
Programming</pub> for a complete description.</p>

</ul>

IDL provides over 750 intrinsic mathematical and other functions, not
to mention the hundreds of others present in the IDL User's Library.  
For example:</p>

<ul>

 <kbd> SQRT EXP ALOG ALOG10 SIN ATAN ASINH  GAMMA  ROTATE RANDOMN <br>
       GAUSSFIT POLY_FIT INT_3D INTERPOLATE SORT STRMATCH ...</kbd>, and so forth.</p>

See the <pub>IDL Reference Guide</pub> for details.</p>

</ul>

Many of the operators and mathematical functions take vector or array
arguments as well as scalars.</p>

Typical IDL command lines might look like this:</p>

<p align=center><pre><kbd>
     a = [45, 90, 135, 180]*(!pi/180.) & y = sin(a)

     z = ((x-xc)^2)/(2.0*sigma^2) & gaussfun = exp(-z)/(sigma*sqrt(2.0*!pi))

     sm_im = smooth(im,5) 

     if (photon_count lt 30) then ran_count = randomn(seed,poisson=photon_count)
</kbd></pre></p>

<ul>

<kbd> </kbd>

Here, <kbd>a</kbd> and <kbd>y</kbd> are vectors, first defined by this
line; <kbd>xc</kbd> and <kbd>sigma</kbd> are predefined scalars;
<kbd>x</kbd> is predefined and can be a scalar or vector, and
<kbd>z</kbd> and <kbd>gaussfun</kbd> will be the same type;
<kbd>im</kbd> is a predefined vector or higher dimensional array, and
<kbd>sm_im</kbd> will be the same type; <kbd>photon_count</kbd> and
<kbd>ran_count</kbd> are scalars, and <kbd>photon_count</kbd> is
predefined; the output of <kbd>randomn</kbd> is an integer if the
<kbd>poisson</kbd> keyword is set, but it is automatically converted
to floating point; if <kbd>seed</kbd> is undefined, it is used as an
output parameter to generate a series of random numbers on subsequent
calls (see the <kbd>help</kbd> listing for <kbd>randomn</kbd>).  </p>

</ul>

</ul>

<u><b>Executive Commands</b></u></p>

<ul>

<kbd>.run [name]</kbd> : compiles the IDL procedure(s) or function(s)
    in the file <kbd>[name].pro</kbd>.  If this is a main program, also
    executes it.  Note the period as the first element of this command.</p>

<ul>

    IDL will <em><b>locate the <u>first</u> file with this name in the
    IDL path</b></em>.  Beware of using names for your own procedures which are
    the same as those of intrinsic or supplied library routines (unless you
    deliberately intend to <u>replace</u> those). </p>

    Program files can contain <b>more</b> than one IDL program.
    Simply concatenate programs together.  All will be compiled by the
    <kbd>.run</kbd> command and recognized separately in future
    calls.  However, it is not recommended that you pack programs
    this way.  Among other things, you lose the capability of reading
    internal headers with the <kbd>man</kbd> command (see above). </p>

    <p> You do <b>not</b> have to give a separate <kbd>.run</kbd>
    command in order to execute a subroutine which is in your path and
    has a file name <b>identical with its procedure name except for
    the added '.pro' extension</b>.  Simply <b>type the command's name</b>,
    with all required parameters, and IDL will <b>automatically</b>
    search the path for such a file and execute it.  If the file name
    does not match the procedure name it contains, then you must
    <kbd>.run</kbd> the file separately. </p>

    You <b>do</b> have to use a <kbd>.run [name]</kbd> command
    to execute a main program the first time.  To re-execute, you can
    use <kbd>.go</kbd>.</p>

    The <kbd>.run [name]</kbd> command will <b>compile but not execute </b>
    a procedure or function file.</p>
    
    You must re-<kbd>run</kbd> any command whose procedure file you have edited
    during your session or the revisions will not take effect.  </p>


</ul>


<kbd>.con</kbd> : Continue a program interrupted by a
    pre-programmed <kbd>stop</kbd> command. </p>

<kbd>.go</kbd> :  Restart a previously compiled main program from
beginning.</p>


<kbd>@[name]</kbd> :  Execute the <b>"batch"</b> file
    <kbd>[name].pro</kbd> containing a list of IDL commands in the
    same form as they would be entered from the keyboard.  Can be used
    to run a large <b>background job</b> or a user-specific
    <b>initialization file</b> at the beginning of a session.  Batch
    files are frequently used to duplicate or iterate a set of
    commands derived from an earlier IDL session (e.g. for graphics
    output).  Such a set is called a <b>"script"</b>.</p>
   
<ul>

Each line is executed separately so that multiple line commands
involving do-loops etc. cannot be included in a script.  (But
subroutines which are called from the batch file can, of course,
include such features.)</p>

You can set up common blocks, compile procedures, and so forth with
batch files.  Text after a semicolon (<kbd>;</kbd>) on a given line is
ignored by the compiler.</p> 


</ul>

An efficient way to <b>update or execute parts of a
script</b>---e.g. a command sequence captured using the
<kbd>journal</kbd> utility---is to run an editor on the script in one
window while executing IDL in another and <b>cutting-and-pasting</b>
snatches of code between them.  This method is especially useful when
you have a large number of options 
(e.g. doing statistics, histograms, and plots on a data file
containing many different variables).  </p>

</ul>

<kbd>execute</kbd>: The <kbd>execute</kbd> command executes any <b>string</b>
containing a proper IDL command.  The syntax is</p>

<ul>

<kbd>result=execute([string])</kbd>  </p>

Here <kbd>result</kbd> will be 1 if the command was successful
and 0 otherwise. </p>

This offers a powerful means of adapting program operation to
contingencies during execution.  For instance, you can create a new
variable whose name and characteristics are based on information read
from a file with contents unknown ahead of time.  Use built-in string
manipulation utilities to create the command string.</p>

</ul>

</ul>

<u><b>Programs</b></u></p>

Programs are structured text files of IDL commands.  They can be stored
anywhere in your IDL path.  There are three different types of
programs, each of which interacts slightly differently with your active
IDL session.  Coding rules differ slightly in each case.</p>

<ul>

<li><b>Main programs</b>: a main program is simply a file of IDL
    commands which can be compiled and executed  by a <kbd>.run</kbd>
    command.  Main programs behave just as though you were typing the same
    commands from the keyboard <em>except</em> that you have full
    access to multiple line entries, blocks, loops, etc, which can't
    be used from the terminal.  A main program will <b>recognize any
    variables or routines already active at the main level of your
    interactive session</b>, and these remain active when the program
    completes.   </p>

<ul>

    Main program files do not have a special header.  Simply start with
    the first executable statement.  A main program file must close with
    an <kbd>end</kbd> statement.</p>

    Main programs cannot be executed by a procedure or function.</p>

</ul>

<li><b>Procedures:</b> IDL "procedures" perform like <b>subroutines</b> in
    FORTRAN.  <b>All inputs and outputs must be specified</b> on the command line
    that calls the routine (or passed through common blocks or IDL
    system variables).  Procedures can be called from the main level
    or by any other procedure.  Procedure calls look like this (note
    the absence of parentheses):  </p>

<ul><ul>

 <pre><kbd>PROCEDURE_NAME,input_parm_1,input_parm_2...output_parm_1,$
output_parm_2...keyword_1=value1,keyword_2=value2....  </kbd> </pre> </p>

</ul>

  <li> <b>Parameters</b> for input/output are separated by <b>commas</b>.  If
    the parameter sequence is too long for a single line, break it into
    several lines using the dollar sign continuation convention (as
    here).  Information can also be passed by common blocks or system
    variables.</p>

  <li> Procedures and functions <b>cannot recognize variables
    active in your interactive session unless they are passed as
    parameters, in common blocks, or as system
    variables</b>.</p>

  <li> Similarly, the main level of IDL cannot recognize variables
  that are defined in procedures or functions but are not passed 
  through calling parameters, common blocks, or system variables back
  to the main program. Internal variables
  vanish on a normal exit from a procedure. </p>

  <ul>
  In the process of debugging procedures, you will want to be running under
  <kbd>on_error,0</kbd> (which is the default).  If an error occurs
  in a procedure, this will stop execution at the procedure level
  and allow you to inspect all of its local variables.</p>
  </ul>

  <li>  As in
    FORTRAN, ordinary parameters must be entered in the <b>specified
    order</b>.  Trailing parameters can be omitted, if there are defaults
    for them coded into the subroutine.</p>

 <li><b>Keywords</b> are parameters that pass information to
    subroutines, but unlike the standard parameters such as those
    listed in the preceding example
    (<kbd>input_parm_1,...output_parm_2..</kbd>), they are
    <b>optional</b>.  They do not have to appear in the subroutine
    call, and if present they can appear in <b>any order</b>.  They
    therefore represent a powerful extension to the rigid subroutine
    call conventions of other high level languages and are especially
    useful in the case of complex data processing tasks.  Values of
    keywords are usually determined by assignment statements:</p>

<p align=center> <kbd>PROCEDURE_NAME,parm_1,parm_2.....KEYWORD_1=100.,KEYWORD_2='dumbo',... </kbd> </p>

    <p>Alternatively, in the case of switches, keywords can be set to a
    value of 1 by using the following syntax:</p>

       <p align=center> <kbd> PROCEDURE_NAME,parm_1,parm_2...../KEYWORD_1,.....</kbd>  </p>

    The keyword name in a calling statement can be <b>truncated</b> to as short
    a string as allows the keyword to be uniquely identified.</p>

    The <kbd> keyword_set(name)</kbd>  function can be used within a subroutine to
    sense whether a particular keyword was set by the user in
    the current call to the subroutine.  </p>

    IDL supports <b>"keyword inheritance"</b> such that keywords which
    may not actually be defined in the procedure declaration but which
    are included in the command that called the procedure can be
    <b>passed through to other procedures</b> that do recognize them.
    This adds considerable flexibility to writing interactive
    software.  See the IDL manuals for details.</p>
    
  <li> Procedure files must start with a special header line, as follows:</p>

   <p align=center><kbd> PRO Name,parm_1,parm_2,...keyword_1=keyword_1... </kbd></p>

      and must close with a <kbd>return</kbd> and an <kbd>end</kbd>
      statement.</p>

</ul>

<li><b>Functions:</b> IDL "functions" perform like functions in
    FORTRAN.  They return output to a single variable  which appears on the left hand side of an assignment
    statement:</p>

<p align=center> <kbd>result = FUNCTION_NAME(parm_1,parm_2...keyword_1=keyword_1...) </kbd></p>

<ul>

  <li>  The parentheses are required, and parameters within them must be
    separated by commas.  As for procedures, only the parameters given
    in the calling sequence or passed through common blocks or
    system variables will be known to the function.</p>

  <li> Don't be misled by the format of the function call.  Functions
    can return a large amount of information.  The variable on the left
    hand side can be an array or structure.  The parameters in
    parentheses can also be used to return output (as in the
    <kbd>count</kbd> parameter of the <kbd>where</kbd> function).
    Information can also be passed by common blocks or system
    variables.  </p>

  <li>  Note the potential confusion which can arise because the format of
    a function call is similar to an assignment statement involving an
    array on the right hand side.  In IDL V5 or later, the default format for
    specifying indices in arrays now uses brackets, rather than
    parentheses---e.g. <kbd>array[i,j,k]</kbd>---although later versions still
    tolerate the use of parentheses.  In older versions of IDL, the way
    to avoid confusion between arrays and functions is to pre-compile
    (non-intrinsic) functions using <kbd>.run</kbd> before you compile
    any procedures which use them or attempt to use them
    interactively.  You will get an "Undefined Variable" error message
    if you neglect to do this.  <p>

<li> Function files must start with a special header line, as follows:</p>

   <p align=center><kbd> FUNCTION Name,parm1,parm2,... </kbd></p>

      and must close with a <kbd>return,[output]</kbd> and an
      <kbd>end</kbd> statement.</p>

</ul>
</ul>

<b><u>Program Examples</u></b></p>

To illustrate some of the differences between main programs,
procedures, and functions, here are three corresponding versions of
the code for determining the length of the first dimension of a given
variable (scalar or array) using the built-in <kbd>SIZE</kbd> function.
Each version is assumed to be stored in a file named <kbd>get_dim1.pro</kbd>
in your IDL path.</p>

<ol>

[Refer to the definition of the <kbd>SIZE</kbd> function in the IDL
help files.  Note that the form of its output -- the intermediate
variable <kbd>s</kbd> in the examples -- depends on the number of
dimensions in the input variable.  Its first element contains the
number of dimensions (zero for a scalar); its second element is the
length of the first dimension.  Note that any text after a semi-colon
(<kbd>;</kbd>) is optional and is ignored by the compiler.]</p>

<li> <b> Main Program</b> </p>
<pre><kbd>
         ; MAIN PROGRAM: get_dim1.pro 
         s = size(a_in)
         if (s[0] eq 0) then d1 = 0 else d1 = s[1]
         end
</kbd></pre>


<li> <b> Procedure </b></p>
<pre><kbd>
         PRO get_dim1,a_in,d1
         s = size(a_in)
         if (s[0] eq 0) then d1 = 0 else d1 = s[1]
         return
         end
            
</kbd></pre>

<li> <b> Function</b></p>
<pre><kbd>
         FUNCTION get_dim1,a_in
         s = size(a_in)
         if (s[0] eq 0) then d1 = 0 else d1 = s[1]
         return,d1
         end
</kbd></pre>

</ol>

To execute these three routines during an interactive session and to
print to the terminal command window the resulting value for the first
dimension, the commands would be as follows.  In all cases, the input
variable <kbd>a_in</kbd> must have already been defined during the
session.  Note that you do not have to give a <kbd>.run</kbd> command
to compile a procedure or function as long as its file name matches
its logical name (except for the <em>.pro</em> extension).</p>

<ol>

<li> <b> Main Program</b></p>
<pre><kbd>
          .run get_dim1
          print,d1
</kbd></pre>


<li> <b> Procedure</b> </p>
<pre><kbd>
          get_dim1,a_in,d1
          print,d1
</kbd></pre>

<li> <b> Function</b></p>
<pre><kbd>
          print,get_dim1(a_in)
</kbd></pre>

</ol>


<u><b>Tips</b></u></p>

<ul>

<li> Add comments to program files and scripts by using a semicolon (<kbd>;</kbd>).
Any text on a given line following a semicolon is ignored by the compiler.
Executable statements can precede the semicolon.  </p>

<a name="retall">
<li><kbd>retall</kbd> : important utility that returns you to the MAIN
    program if an error occurs in a subroutine.  The default in this
    case is to remain under control of the subroutine (so that you
    can debug the routine by examining the current values of
    its variables, for instance). </p>

<ul>
    The danger if you do not return to MAIN is that you will perform
    other tasks (e.g. reading in new data) under control of the
    subroutine but later exit the routine, leading to the disposal of
    all such data.  Type <kbd>retall</kbd> to escape the subroutine.</p>

    An alternative is to set <kbd>on_error,1</kbd> at the beginning of
    a session, which automatically returns to the MAIN level after an
    error.  <kbd>on_error,0</kbd> sets the default mode (stay in the
    subroutine).  </p>

    You can check where you are by typing <kbd>help</kbd>.  The first
    line of the printed information block lists your current location
    (procedure name and line).  </p>

</ul>

<li><b>If using the cursor, remember to place it on the
   <em>active</em> window</b> (defined by the <kbd> wset</kbd> or
   <kbd>chan</kbd> routine) before clicking; errors result otherwise.
   Return the cursor to the command window when finished with cursor
   function.</p>

</ul>

<u><b>Importing software</b></u></p>

<ul>

There are scores of sites on the Web that distribute
IDL programs.  To use these, all you need do is
<b>download them, unpack (if necessary) to source-file format (ASCII),
and place them in a directory in your IDL path</b>.  The path-search
protocol described above under the <kbd>.run</kbd> command will then
locate and execute each program file when you ask for it. </p>

You can do this before or during an interactive IDL session (though
you cannot change your IDL path during a session).  You must, of
course, be sure you have all the subsidiary programs needed by the new
software also in your path.</p>

</ul>


<hr>

<h2 align=center> <a name="retrieve"> 4. DATA AND IMAGE RETRIEVAL </a>  </h2>

<p><a href="#contents"> [Up to Contents]</a></p>

<p><a href="#store"> [Down to Data and Image Storage]</a></p>

<u><b>Data transfer to memory</b></u></p>

<ul>

During an active session,
<b>IDL maintains relevant data in random-access memory</b> stored in
variables with arbitrary names chosen by the user.  The first step
in IDL data analysis is normally therefore to <b>read data or image files
from disk storage into IDL variables in RAM</b>. These variables can be
manipulated at will using arithmetic, extraction, compression,
expansion, renaming, conversion, and a multitude of other built-in and
user-supplied functions.  They can be written back to disk as files
in various formats.  </p>

Note that this is <b>in contrast to IRAF and most other standard astronomy
software packages</b>, where there is no intermediate data storage, all
manipulation begins and ends with data stored as <b>files</b>, and one
must refer to data sets by their file names at all stages in the analysis
process.</p>

IDL can read/write files up to 2.2 GB in size (and longer on some
platforms).  However, your host computer may have limitations that
prevent access to files this large.  See the "Files and I/O"
chapter of the <pub>Building IDL Applications/Application
Programming</pub> manual for information on handling large files.</p>

<ul>  (In certain situations, it may be preferable not to have IDL
read an entire file into RAM.  Here, you can instead use the
<kbd>ASSOC</kbd> function to transfer only part of a file as it is
needed; the data will not be held in RAM.) </p>
</ul>

Note that any filename must be given as a <b><em>string</em></b> in the
commands described below.  That is, it must be <b>quoted</b> (unless you use a
pre-defined string variable).  Example:
<kbd>fits_info,'m87_nucleus.fits</kbd> (the trailing quote mark can be
omitted if it is the last entry on a line).  Wildcard notation can be
used with routines that can take multiple file input (e.g.
<kbd>fits_info,'m87*.fits</kbd>).  </p>

</ul>

<u><b>Directory Routines</b></u></p>

<ul>

<li> <kbd>sd,[directory]</kbd> or <kbd>cd,[directory]</kbd> : change
    directory to the image directory, like <kbd>cd</kbd> in LINUX.  The
    directory name must be a <b><em>string</em></b>.
    <kbd>sd</kbd>, without an argument, is equivalent to
    <kbd>$pwd</kbd>.   </p>

   <ul> Note: a <kbd>$cd</kbd> command to the shell
    will <b>not</b> change your default IDL directory.  </p>
   </ul>


<li><kbd>dir</kbd>: list the contents of the current directory.</p>

<li><kbd>print,file_which([name])</kbd>: prints the location of a file
with a given name.  The file must be in a directory in your path.</p>

</ul>

<a name="asciifiles">
<u><b>ASCII Files</b></u></p>

<ul>

ASCII files consist of formatted alphanumeric and related characters.
They are easy to read and edit, and they are readily transferrable
between computer operating systems.  ASCII files are widely used to
store modest amounts of data and are commonly used to output
information from spreadsheet programs, digital astronomical catalogs, etc.</p>

The basic IDL routine for reading ASCII files is 
<kbd>readf</kbd>.  It is normally used with the <kbd>format</kbd>
keyword, which specifies the structure of the file.</p>

<ul>
Format statements in IDL are very similar to those in FORTRAN or C. 
Sample code to read a file containing
target names, coordinates, and brightnesses might look like the following:</p>

   <pre align=center><kbd>
       get_lun,unit
       openw,unit,'InputFile'
       form='(a15,3x,f9.5,3x,f9.5,3x,f6.2)'
       for i=0,numtarg-1 do readf,unit,format=form,$
               targid[i],radeg[i],decdeg[i],vmag[i]
       close,unit
 </kbd></pre> </p>

In this approach, the number of data lines in the file
(<kbd>numtarg</kbd>) must be defined ahead of time.  An intrinsic IDL
utility that can help with this task for ASCII files is
<kbd>file_lines</kbd>.</p>

Because the <kbd>for</kbd> statement in this script refers to
individual elements in the arrays designated to hold the incoming
data, these arrays must be <u>pre-defined</u> to accommodate the
number of elements expected to be in the <kbd>InputFile</kbd>.  E.g.
<kbd>radeg=fltarr(numtarg)</kbd>.  The arrays can also be defined to
be larger than entries in any likely input file and then truncated
after the script executes.</p>

An alternative approach, which does not require knowledge of the file
length, is to read the file line by line, checking for the "end of
file" mark, and then bumping up each vector after each successful
read: e.g. <kbd>targid = [targid,newid]</kbd>, where <kbd>newid</kbd>
is the latest value read.  </p>

<!-- *** ELABORATE: on pre-definition of variables needed in
this situation.  Also in format-free readf.  However, NOT
needed when using "readcol".  Done.

Could explain alternate use of z=[z,newitem] syntax to enlarge arrays
during line-by-line read of file of unknown length.  Done. 

Add entry for "file_lines" -- intrinsic utility to determine
number of lines in an ASCII file. Done. 

--> 


</ul>

Depending on the structure of the input file, <kbd>readf</kbd> can also
be used in a <b>free-format</b> mode, where the <kbd>format</kbd>
keyword is not needed and file elements are separated by commas
or white space.  See the IDL manuals.</p>

</ul>

<a name="readcol">
<kbd>readcol</kbd> is a very handy AstUseLib utility for reading ASCII
files <b>consisting of separate columns of numerical data <u>without</u>
having to specify a file format</b>.  An example of the use of
<kbd>readcol</kbd> is given in <a href="#plot4">Plotting Example 4</a>
below. </p>

<ul>

Syntax:  <kbd>readcol,'[Filename]',v1,v2,v3,v4... </kbd></p>

The columns can be <b>separated
by blanks or commas</b> (or other characters specified by the optional
<kbd>delimiter</kbd> keyword) but do <b>not have to be aligned</b>.
</p>

<!-- By default, entries are assumed to be floating-point numbers.  --> 


The vector variables into which the columns are read by
<kbd>readcol</kbd> do <b>not have to be predefined</b>.</p>

The <kbd>open</kbd> and <kbd>close</kbd> commands are included within
<kbd>readcol</kbd>, so no separate commands are needed.</p>

<kbd>readcol</kbd>
accepts simplified format specifications and can read alphanumeric fields
as well as numeric fields (however, no blanks or commas can appear in alphanumeric
fields). </p>

<kbd>readcol</kbd> is well suited to reading the comma-separated-value
files produced by <b>spreadsheet programs</b>.</p>

<kbd>readfmt</kbd> is a corresponding AstUseLib utility for fixed-format
entries.  You must specify the format, but the routine will execute
much faster because it does not have to test the structure of each
input line.</p>

Both the <kbd>readcol</kbd> and <kbd>readfmt</kbd> routines have the
nice feature that they will <b>skip over comment lines</b> (or other
lines with non-matching formats) without choking. </p>

</ul>
</ul>

<a name="binfiles">
<u><b>Binary Files</b></u></p>

<ul>

Binary files store data in the internal representation used by
computer RAM.  They are more compact and much faster to read and write
than ASCII files because character conversions are not required.
Binary files are therefore preferred to store large amounts of data,
e.g. images.  However, ordinary binary files are not necessarily portable
between operating systems.</p>

The basic IDL routine for reading unformatted binary files is
<kbd>readu</kbd>. </p>

IDL supports the creation and reading of
<b>portable binary files</b> with the optional <kbd>xdr</kbd> keyword
used with the <kbd>open</kbd> procedure.  See the IDL manuals.</p>

The file types discussed in the rest of this section are all <b>modified
binary formats</b> which are standardized or internally documented such
that they are <b>portable</b> among computer operating systems.</p>

</ul>

<u><b>FITS Files</b></u></p>

The standard data format for most astronomical data sets today is the
<a href="http://fits.gsfc.nasa.gov/"> Flexible Image Transport System
(FITS)</a> format.  The IDL Astronomy Users Library contains a large
package of routines to manipulate FITS files.  Intrinsic IDL supports
a variety of other common scientific data formats (see the manuals for
details) with similar functionality.</p>

<ul>

<li><b> FITS file information utilities</b></p>
<ul>

    <kbd>fitsdir</kbd>: list (selectable) keywords from the headers of
    FITS files in the current directory.   </p> 

    <kbd>fits_info</kbd> and <kbd>fits_help</kbd> list information
    concerning the structure of a FITS file (number of extensions, sizes
    of headers and arrays, etc) without reading the entire file.
    This can be important to confirm the type
    of file (image, table, etc.) with which you are dealing. <kbd>fits_info</kbd>
    will operate on a list of files.    </p>

    <kbd>headfits</kbd> (a function) will read the full header of a
    FITS file on disk into an IDL variable (without reading the
    data).  You can then display the contents of the header with
    either the <kbd>print</kbd> or <kbd>hprint</kbd> commands (the
    latter intended for FITS headers).  <kbd>headfits</kbd> will work
    on compressed files (*.Z or *.gz).</p>

<ul>
   E.g.:  <kbd>hprint,headfits('m87_nucleus.fits.gz')</kbd>  </p>
</ul>
</ul>

<li><b> FITS file reading routines</b>.  There are several different
sets of utilities for accessing FITS files.  For a comparison of their
advantages and disadvantages, see <a
href="http://idlastro.gsfc.nasa.gov/fitsio.html">
http://idlastro.gsfc.nasa.gov/fitsio.html</a>.  The two most widely
used are probably <kbd>fits_read</kbd> and
<kbd>mrdfits</kbd>.  </p>
 

<ul>

<li><kbd>fits_read,[filename],[image variable name],[header variable
    name],...</kbd> : read a FITS disk file into IDL image and header
    variables.</p>

<ul>

    <p> Example:  <kbd> fits_read,'m87_nucleus.fits',m87,hdm87,/noscale </kbd></p>

    This command reads the image data in the FITS image file
    <em>m87_nucleus.fits</em> in the current directory into active
    variable <kbd>m87</kbd> and the
    corresponding header section of the file into active
    string array variable <kbd>hdm87.</kbd>
    <kbd>m87</kbd> will have the
    characteristics (byte, integer, float, etc.) of the FITS file data.
     </p> 

<!-- following patch works for SDAS files, not FITS

    <p>If the header does not contain parameters which properly match
    the file (e.g. <kbd>NAXIS, BITPIX, DATATYPE</kbd>), then an error
    message will appear.  However, you can create a dummy header which
    does match the data in this case and store it on the image
    directory; see "Image Storage" below.</p> 

 -->

    The optional <kbd>noscale</kbd> keyword used here prevents the
    (default) automatic scaling that converts the image values to
    fluxes using calibration parameters in the header.  For many
    purposes, the scaling is a nuisance.</p>

</ul>

    <li> <kbd>fits_read</kbd> can handle <em>extensions</em> and
    <em>groups</em> in FITS files.  Among the alternatives,
    <kbd>fits_read</kbd> is the best current choice for HST data sets,
    for instance.  </p>

    <li> The corresponding routine to write a FITS file is <kbd>fits_write</kbd>
    (see <a href="#store">below</a>). </p>


</ul>

<li> <b>FITS table utilities</b>.  There is an entire suite of
Astronomy User's Library routines to read, write, or manipulate FITS
ASCII or binary
 <b><em>tables</em></b>.  For more information, see <a href=
"http://idlastro.gsfc.nasa.gov/ftp/pro/fits_table/aaareadme.txt">
http://idlastro.gsfc.nasa.gov/ftp/pro/fits_table/aaareadme.txt</a>. </p>

<ul>

    For instance, to read a FITS file containing a
    binary table of sources and extract coordinate information: </p>

     <ul>

       <p><pre> <kbd>
       fits_read,'sources_file.fits',table,hdtable

       tbhelp,hdtable     ; List contents of each field 
                          ;   from the header

               ; Extract RA and DEC vectors, based on
               ;   tbhelp listing:

       rad    =  tbget(hdtable,table,1)
       decd   =  tbget(hdtable,table,2)
          </kbd></pre>

     </ul>

    Alternatively, you could perform the same extraction as follows:</p>
     <ul>
     <pre><kbd>
        ftab_help,'sources_file.fits'   ; List contents  
        ftab_ext,'sources_file.fits','RA','DEC',rad,decd  </kbd>
     </pre>
 </ul>
</ul>


<li> <b>FITS header keyword extraction/manipulation.</b>  There
     are many commands, mostly starting with the prefix <kbd>sx</kbd>,
     that permit extraction and manipulation of FITS keywords. </p> 

<ul>
For instance, to extract and print the name of a target from a 
FITS image header variable:</p>

<ul>
 <kbd>targ = sxpar(hdm87,'TARGNAME') & print,targ</kbd>. </p>
</ul>

To add a history comment to a FITS header variable: </p>

<ul>
<kbd>sxaddhist,'22 AUG 2004: Subtracted mean sky background',hdm87</kbd>
</p>
</ul>

To add a new parameter in a FITS header variable or modify an existing
one, use <kbd>sxaddpar</kbd>.</p>

</ul>

</ul>


<b><u>SDAS and IRAF files</u>:</b> These file formats, which store data
and header segments separately, are now deprecated, but the AstUseLib
has read/write routines for them.  See <kbd>strd</kbd> and
<kbd>irafrd</kbd>, respectively.</p>


<b><u>Other Image Formats</u>:</b> 

<ul>

 Users have produced IDL routines to
    read most of the other standard image storage formats.  See:
    <kbd>read_gif, read_jpeg, read_srf,
    read_tiff,</kbd> etc.  There are corresponding <kbd>
    write</kbd> routines for all of these. </p>


Exelis also supplies an intrinsic file reader that will read most
commercially important image file types.  Use the command
<kbd>checkim=query_image([filename],info)</kbd> to determine whether a
particular file is in a suitable format.  If so, the returned value of
<kbd>checkim</kbd> will be 1 (0 if not).  For details on the file
structure, type <kbd>print,info,/str</kbd>.  Use the
<kbd>read_image</kbd> function to read the file and its associated
color tables, if any (see the help files and the next section
for information on color tables).</p>

</ul>

<b><u>Endian-Conversions</u></b></p>

<ul>

"Endian" refers to the storage
convention adopted for multiple-byte quantities by your computer's
memory management system.  If the most significant byte is stored
first, this is a "big-endian" convention.  If the least significant
byte is stored first, this is a "little-endian" convention.  As you
might expect, manufacturers have not been able to agree on a universal
standard for byte order.  Therefore, you will likely be faced
occasionally with having to <b>convert byte order</b> for data read
from files generated on other computers.  This is <b>not</b> an
issue in reading/writing FITS files.  But it could arise in reading
other types of binary files written on a different computer
architecture.  A symptom of an "endian-ness mismatch" is unusually
large or small numbers in data where these
are not expected. </p>

<!--  MAC OS-X Intel (x86) architecture is
little-endian.   -->

IDL includes the <kbd>swap_endian</kbd> function, which allows
you to change the storage convention for data in your session.  It
also allows you to identify the convention adopted by your computer,
as in the following: </p>

<ul>
<pre><kbd>
a=3.0e5  ; Define a large number
b=swap_endian(a,/swap_if_big_endian) & print,b
     ; If b is different from a, your machine is big endian
     ; If b is the same as a, your machine is little endian
</kbd></pre>
</ul>

If your machine does not match the computer that generated the
relevant data file, then use <kbd>swap_endian</kbd> to swap
the stored data.  </p>

</ul>
</ul>

</p>

<p><br></p>

<hr>

<h2 align=center> <a name="display"> 5. IMAGE DISPLAY </a> </h2>

<p><a href="#contents"> [Up to Contents]</a></p>


Much of the power of interactive computing comes from your ability
to make immediate displays of plots or images on your terminal. 
Hardware considerations impinge more on making such displays than on
other aspects of interactive computing.</p>

This section describes the underlying mechanics of image graphics and
the basic IDL command-line routines for making image displays.  <b>If you
are only interested in getting a quick display of astronomical images,
skip to the description of</b> <a href="#ATV">the ATV display tool</a> in
the next section.  For making plots, see <a href="#plots">10. Plots</a>
below.</p>


<u><b>Color Graphics Displays</b></u></p>

<ul>

Color monitors utilize three color injectors---red, green, and blue
(RGB)---each of which can be adjusted to 256 different intensity
levels at a given screen location.  In principle, they can therefore
display 256^3 = 16.8 million different colors at any point.  Until the
past ten years or so, however, most computer monitors were capable
of displaying only one byte (8 bits, or 256 different levels) of
information at a given location.  These are known as 8-bit monitors.
Users were forced to choose only 256 out of the 16.8 million possible
color values for their displays.  This kind of limited display
environment is called a <b>pseudo-color</b> or <b>indexed-color</b>
display.  Most IDL (and other scientific image processing) software
written up to 2001 assumes pseudo-color displays.  </p>

Modern computer monitors, probably including the one you are using,
feature 24-bit displays.  That means they are capable of utilizing all
possible 3-color combinations.  IDL image displays using this
maximum color palette are known as <b>true-color</b> displays. </p>

Naively, you would expect that anything labeled "true" has got to be
better than something labeled "pseudo."  And you would be right---if
you were interested in processing commercial digital camera images or
making glamorous press-release versions of astronomical images.  But
that's not the main concern of most astronomers.  Instead, you will
discover that working with displays in <u>pseudo-color</u> (native to an 8-bit
monitor or emulated on a 24-bit monitor) is most appropriate and
convenient.</p>

<ul>

The reasons are, first, that the human eye usually cannot distinguish
even 256 levels of intensity or color so that the additional color
resolution possible in 24-bit displays is rarely of scientific value.
(Aesthetics are another matter.)  Second, most images of interest to
you will be intrinsically monochromatic.  In fact, most basic image
analysis work in astronomy is based on <b>gray-scale</b> displays.
Finally, the use of true-color displays requires the creation of
3-dimensional arrays (three elements are needed at each x,y position
to feed the three color injectors), whereas the scientific images you
will start from are typically 2-dimensional.  Conversion back and
forth between 2-D and 3-D adds needless complications.  </p>

</ul>

Accordingly, <b>most of the subsequent discussion is aimed at
indexed-color/pseudo-color displays</b>, whether on 8-bit or 24-bit
monitors.</p>

</ul>


<u><b>Displayed Arrays and Color Tables</b></u></p>

<ul>
The array that is sent to
your monitor hardware for display must be a <b>byte array</b>, which
means that its element values are always in the range 0-255.  
</p>



<li> <b>24-bit Monitors</b>:  On a 24-bit monitor, the displayed array
is always a 3-D IDL byte array, one of whose dimensions is always 3.
Each index in this dimension codes for one of the three color
injectors.  The array structure can be <kbd>im(3,width,height)</kbd>,
<kbd>im(width,3,height)</kbd>, or <kbd>im(width,height,3)</kbd>.  In
the last of these forms, the red, green, and blue image planes are
stored sequentially.  In the first of these forms, the "color-triples"
at each pixel are stored together: that is, the first six elements in
storage will be <kbd>r_00,g_00,b_00,r_10,g_10,b_10</kbd>, where
<kbd>r_00</kbd> is the red intensity in the (0,0) pixel, and so
forth.  The entered values are converted directly into brightnesses of
the monitor's 3 color injectors.</p>

In the case of a color photograph, for instance, a 24 bit monitor can
display the full palette of colors that are embedded in the image, and
hence 24-bit displays are called <b>"true-color"</b> displays.
However, the colors do not necessarily have to correspond to perceived
ones.  The most widely used true-color image file format today is the
<b>JPEG</b> format (though this is not normally employed for scientific
data).  </p>

<li> <b>8-bit Monitors</b>:  On an 8-bit monitor, the displayed array is
always a 2-D IDL byte array, <kbd>im(x,y)=n</kbd>, where <kbd>n</kbd>
is called the <b>index</b> of the display at pixel <em>(x,y)</em>.
The entered index value must be <b>converted</b> into brightnesses for
the 3 color injectors by using an intermediary known as a <b>color lookup
table</b>.  </p>

<ul> 

<b><u>Color Tables</u></b>:  A color table consists of three byte vectors
<kbd>R,G,B</kbd>, each 256 elements long, containing values between 0
and 255.  If a given pixel contains the index value <kbd>n</kbd>, the
red, green, and blue injectors at that pixel are set to the values
<kbd>[R[n],G[n],B[n]]</kbd>. The resulting appearance on
your computer screen therefore depends <em>both</em> on the array
values <em>and</em> the color table. </p>

For a "gray-scale" color table, <kbd>R[n]=G[n]=B[n]</kbd>.  If the
three vectors contain different entries, a colored display will
appear.  These colors have no necessary relation to the physical
appearance or properties of the object in the image; hence such
displays are called <b>"pseudo-color"</b> displays; more generally,
they are called <b>"indexed-color"</b> displays.  However, there is a
direct correspondence between the index values in the image array and
the colors which appear on the screen.  Although it does not add
fundamental information, pseudo-color display of a 1-byte array can be
very useful in exploring subtle structures in a complex image, for
instance.  Pseudo-color displays need not appear "unnatural"; they can
closely approximate a true-color display but are inherently limited to
only 256 levels of color/intensity.  The <b>GIF</b> format stores images in
2-D indexed form with an accompanying color table. </p>

On a 24-bit monitor, a color table is used in the "emulated"
index-color mode set with the <kbd>device, decomposed=0</kbd> command
(see next entry).  But <b>color tables have no effect in the standard
true-color mode</b> described above.</p>

</ul>

<li> <b>Indexed-Color Displays on a 24-bit Monitor</b>: Because
indexed/pseudo-color displays are more useful in many scientific
applications than is true-color, IDL allows you to <b>emulate
indexed-color displays</b> on a 24-bit monitor.  In this mode, you again
must supply a 2-D byte image array and a color lookup table (as
for an 8-bit monitor).  The display commands will then use the color
table to create a 3-D true-color image which will appear on the
monitor just as the pseudo-color image would have appeared on an 8-bit
monitor.  In order to use this mode, you must declare <kbd>device,
decomposed=0</kbd> (more details in next section).  </p>

<!-- Compared to plain
8-bit displays, there are several inconvenient features in this
emulated mode, but they can be overcome (see next section).</p>
-->

</ul>


<u><b>Setting a Visual Display Mode on Your Computer</b></u></p>  

<ol>

<li> The first step is to <b>determine which "visual display classes"
your hardware can support</b>.  At the LINUX prompt, type
<kbd>xdpyinfo</kbd>.  (You must be in X-windows to use this command.)
This will print a list of the display configurations possible on your
system.  The entry <emp>"class: Pseudocolor, depth: 8
planes"</emp> indicates that your system supports 8-bit pseudo-color
displays.  The entry <emp>"class: TrueColor, depth: 24
planes"</emp> indicates your system supports 24-bit true-color
displays.  Some systems will support both of these. </p>

<ul> On Apple MAC OS-X systems, the standard X-11 package
can be set to different visual classes.  Start X-windows.  Click on
X11 ===> Preferences ===> Output.  The "Colors" menu gives you a choice
of the numbers of colors possible.  "256 colors" is pseudo-color mode.
"Millions of colors" is true-color mode.  (Most X-11 releases support
both.)  Make your selection.  You must quit the X-11 program and
restart it for the changes to take effect.  You can check your
selection by giving the <kbd>xdpyinfo</kbd> command within an X-window.</p>
</ul>

<li> <b>Define a visual class for your session.</b> Start IDL.  The
<b>first</b> command you give that references a window display
function or the <kbd>device</kbd> utility determines the visual
display class that will be used throughout your session.  You
<b>cannot change classes</b> after that first command.  Therefore, it's
usually best to put explicit configuration commands using
a <kbd>device</kbd> call in a startup file that is executed before your
interactive session begins.  The three relevant forms of the
<kbd>device</kbd> call are the following: </p>

<ul>

<li> For 8-bit pseudo-color:  <kbd>device,retain=2,pseudo_color=8</kbd></p>

<li> For 24-bit true-color:  <kbd>device,retain=2,true_color=24,decomposed=1</kbd></p>

<li> For 24-bit emulated pseudo-color:
<kbd>device,retain=2,true_color=24,decomposed=0</kbd></p>

</ul>

The <kbd>retain=2</kbd> keyword requests IDL to handle the "backing store" for
your display (which holds copies of parts of your display that have been
overwritten); this avoids malfunctions that can occur if instead
your windows system does the backup.</p>

These commands must be given <b>before</b> any window is created during your
session.</p>

In the absence of a <kbd>device</kbd> command, the default assumed on
a 24-bit monitor is <kbd>true_color=24,decomposed=1</kbd>. </p>

To check the current status of your graphics device, type
<kbd>help,/dev</kbd>.  (Note: the emulated pseudo-color mode is
indicated by the entry <emp>"Graphics pixels:
Combined"</emp>.)</p>

Although you cannot change the visual class after its first
implementation during a given session, in 24-bit mode you <b>can</b>
toggle between <kbd>device,decomposed=1</kbd> and
<kbd>device,decomposed=0</kbd> as desired.  </p>



<li> <b>Reserved Colors on 8-bit Monitors</b>:
With an 8-bit monitor, the maximum number of colors available for all
applications is 256.  When IDL is invoked, it will normally be able to
obtain only a fraction of these, say 210, for its use from your
windows manager because other applications (Firefox, Acrobat, etc)
will have already reserved some colors.  The number will vary
depending on the number of competing applications.  The standard
image transfer and display routines like <kbd>tvscl</kbd> and
<Kbd>tvlct</kbd> take this into account by using the smaller number of
color levels but adjusting them to the full dynamic range possible on
your terminal display.  For instance, the color vectors may be only 210
elements long, but these will range in index value from 0 to 255.  The
number of colors available is contained in the system variable
<kbd>!d.n_colors</kbd> or can be displayed with
<kbd>help,/dev</kbd>. </p>

<b>"Color Flashing"</b>:  If the rest of your 8-bit terminal display
blinks out or changes color when you move the cursor into an IDL
window, then IDL is using a "private color table" which gets applied
to your whole screen when the cursor activates it.  This probably
means IDL is attempting to use more colors than were free in the
shared color table.  To ameliorate the problem, try this:

<pre>
               Exit IDL
               Restart IDL
               As the very first two commands, type:
	           <kbd>device,retain=2,pseudo_color=8</kbd>
                   <kbd>window,0,col=k</kbd>
</pre>

...where <kbd>k</kbd> is the minimum number of color levels you think
will be acceptable in your displays.</p>

Color flashing will not occur on a 24-bit monitor even in
emulated pseudo-color mode.</p>

</ol>

<u><b>Transforming Images for Display</b></u> </p>

<ol>

The hardest part of displaying images is selecting the range of image
values you want to display and then making them distinct on the screen.</p>

The array you send to your display must be a 2-D byte array
(pseudo-color) or a 3-D byte array (true-color).  <b>The descriptions
below are for intrinsic or emulated pseudo-color</b> based on 2-D
images and involve the use of color tables.  There are various
utilities for converting your original array (often floating-point) to
the proper format and automatically displaying it with pre-defined
color tables.  </p>

<li> First, you must decide on the <b>size and shape</b> of the
display.  Depending on the application and the size (in pixels)
of your monitor, you may want to compress the original image
or extract subarrays from it.  In order to inspect the pixel
structure of the image, you can expand images so that one original
pixel occupies, say, a 10x10 pixel area on your screen.  Basic
utilities for extraction or enlargement of images are discussed
under <em>"<a href="#inspect">Data Inspection & Manipulation"</a></em> below.</p>

<li> Next, you must <b>determine the range of original image values,
<kbd>imin</kbd> to <kbd>imax</kbd>, you wish to display</b>.  The
human eye cannot normally distinguish 256 levels of either gray scale
or color, and astronomical images often contain much more than a 256:1
intensity range.  Only rarely would you want to display the whole
range of values present in an image.  Normally there is a significant
sky background or bias/dark current pedestal which needs to be clipped
out.  Often, the highest values in images are caused by cosmic rays or
other artifacts and lie far above scientifically interesting values.
</p>

<ul> To determine the appropriate min/max values you could proceed
by trial and error, iterating the image display.  More objective
methods include using the image value histogram;  determining
the mode of the sky background and its standard deviation; and making
plots of sample slices across the image.  Or, you could rely on any of
several programs in the user libraries.  </p> </ul>

<!--  Intrinsic IDL and the user libraries provide
a variety of tools for doing this.  Once you have made a good visible
display, transferring it to hardcopy such that its quality is
preserved is yet another challenging step.  See <a href="#hard">Graphics
Hardcopies</a> below. 
-->

<li> Next, you must <b>decide on the transformation</b>, or rescaling,
between image values and display values.  Most common is a <b>linear
transform function</b> in which the zero point is determined by
<kbd>imin</kbd> and the slope is determined by <kbd>imax-imin</kbd>.
The original image value range is divided into 256 equal bins for
display.  Contrast in the display increases with the slope, which is
inversely proportional to <kbd>imax-imin</kbd>. 
Most image display routines (such as <kbd>tvscl</kbd>) employ a
linear transform.  </p>

<ul>

Depending on the distribution of interesting image values within the
chosen range, a <b>non-linear transform</b> may be more useful.  For
instance, to increase contrast at lower image values and decrease it
at higher values, you might use transforms such as
<kbd>alog10(f)</kbd>, <kbd>f^0.3</kbd>, or <kbd>asinh(f)</kbd>.
Segmented linear or step-transforms can also be useful.  Whatever
special transform you apply to the image, you can then use the standard
(linear) routines to display the transformed values. </p>

Alternatively, in pseudo-color you can use a linear transform of image
values but manipulate the <b>color table</b> to achieve non-linear
discrimination in the displayed image.  In some situations, this may
be preferable, but it is usually more complicated than simply
changing the mathematical transform.</p>

</ul>

<li> Finally, you must <b>select a color table</b> for the display and
apply it.  The appearance of images can change dramatically depending
on the color table settings.  In pseudo-color mode, the color table is
stored separately by the hardware and is always ready to be applied to
a displayed image. The default color table is a linear gray-scale
running from 0 to 255.  IDL supplies a total of 41 pre-defined color
tables, and there are various tools for modifying these or creating
new ones.</p> 

</ol>

<p><br></p>


<u><b><a name="dispcommands"> Image Display Commands:</a></b></u></p>

The basic IDL direct graphics routines for opening, displaying, and
adjusting image display windows are <kbd>window</kbd>, which creates a
new window and sizes it; <kbd>wset</kbd>, which defines the "current"
window; and <kbd>wshow</kbd>, which reveals (or hides) the current
window.  <kbd>wdelete</kbd> deletes a window.  These routines are used
in conjunction with the two basic image display routines
<kbd>tv</kbd> and <kbd>tvscl</kbd>.  </p>

<ul>
For instance, to open a 512x512 window with index number <kbd>9</kbd> 
at the lower right of your terminal display:

<p align=center><pre> <kbd>         
              window,9,xpos=750,ypos=50,xsize=512,ysize=512,$        
                 title='IDL IMAGE WINDOW'
              wset,9
              wshow
</kbd></pre></p>

(All of the arguments in the <kbd>window</kbd> routine are optional.)</p>

The basic <kbd>tv</kbd> and <kbd>tvscl</kbd> commands do not adjust the
size of the current window to the size of the displayed array.</p>

</ul>


The routines <kbd>chan,cdel,ctv,ctvscl</kbd> described below are
<u>MOUSSE versions</u> of the intrinsic IDL windowing/display
routines.  They offer important convenience features that make work
with images faster (e.g. rescaling of window sizes to the image size,
combination of the window set and show functions, arbitrary min/max
values for the display, etc.).  These routines use special common
blocks, and to initialize those you must run the Mousse Startup File
<a href="#startex"> (see Appendix C).</a> The descriptions below are
for this set of substitutes for the intrinsic routines.</p>

<ul><ul> Note: <kbd>ctv</kbd> and <kbd>ctvscl</kbd> are intended for 8-bit
   pseudo-color or 24-bit emulated pseudo-color displays only.  They
   do <b>not support true-color displays</b>.  If you want to display
   intrinsically true-color images, you must use <kbd>tv</kbd> and
   <kbd>tvscl</kbd>.</p>
</ul></ul>

<ul>

<li><kbd>chan,N</kbd> (similar to intrinsic <kbd>wset</kbd>):  select
   window <kbd>N</kbd> for display .  This becomes the "active" window, i.e.
   available for I/O.  The cursor will only work on the active
   window.  Creates and displays the window if it did not exist before
   (i.e. substitutes for the <kbd>window</kbd> and <kbd>wshow</kbd>
   functions).  <kbd>N</kbd> can be between 0 and 31.  [Although a
   display window will be automatically opened by any display
   procedure the first time it is called, you should use the
   <kbd>chan</kbd> procedure first if you want to take advantage of
   Mousse functionality.  It is also a good idea to keep plotting and
   image display windows separate.]<p> 

<li><kbd>cdel,N</kbd> (similar to <kbd>wdelete</kbd>):  Delete window
   <kbd>n</kbd>.  You can also quit or iconify windows during an
   IDL session by using the regular window manager functions.<p> 

<li><kbd>ctv,image</kbd> (similar to <kbd>tv</kbd>): display image in
   current window (or window 0 if no other window has been opened)
   <u>without scaling</u> by transferring image pixel values directly
   to the window buffer.  The image buffer will contain
   <kbd>byte(image)</kbd>---i.e.  values between 0 and 255 only---and
   will "wrap" for values of 256 and higher.  Only
   <kbd>!d.n_colors</kbd> different values can be displayed (determined
   by your monitor).  The window size is adjusted to match the
   original image (in pixels).  Among other things, <kbd>ctv</kbd> can
   be useful for locating interesting low contrast features in an
   image with a large dynamic range.<p> 

<!-- Default ctvscl scaling is:  min = skymode -0.12*skysig;
     max = skymode+12.0*skysig.   -->

<li><kbd>ctvscl,image</kbd> (similar to <kbd>tvscl</kbd>): as for
   <kbd>ctv</kbd> except that the buffer values are <u>scaled
   linearly</u> between the sky value (set to display value 0)
   and a high point determined by the variance of the fluxes in the
   image.  There is no wrapping.  The maximum number of color levels
   displayed on the screen is <kbd>!d.n_colors</kbd>.
   <kbd>ctvscl</kbd> is generally much more useful than
   <kbd>ctv</kbd>; it has a number of optional features you may
   want to explore.</p>

<ul>

 If you don't like the defaults, you can specify the maximum and
 minimum data values by using the optional keywords <kbd>max</kbd> and
   <kbd>min</kbd>.  E.g.

  <p align=center> <kbd>   ctvscl,m87,min=30,max=8000 </kbd> </p>

 It is easy to iterate displays by recalling the command line and
 editing the <kbd>min,max</kbd> values. </p>

<ul>

   From this example you can see the advantages of rescaling images to
   convenient values in the range 0 to a few thousand rather than
   using actual flux values.  To rescale, use commands like <kbd> m87 =
   1.0e15*m87</kbd>.  In fact, if the quality of the display
   is your only concern, there is no point in retaining actual flux
   values in your working image set.  Just remember not to
   use the scaled image for computations where the units matter.  </p> 

</ul>

  
Note: the intrinsic IDL routine <kbd>tvscl</kbd> does not accept
min/max keywords and always scales between 0 and the maximum data
value in the image.  If that is not appropriate, you must
independently clip the image before input to <kbd>tvscl</kbd>.
Because of this, the display following the command
<kbd>ctvscl,image</kbd> will differ from that of
<kbd>tvscl,image</kbd>. </p> 

</ul>
</ul>

<!--  OBSOLETE UNTIL CONTRAST, ETC ARE REWRITTEN FOR 24 bit MONITORS

May want to call this
section "interactive image adjustment"? ***</p>

<li><kbd>contrast</kbd>: A MOUSSE routine which interactively adjusts,
   using the cursor, the color tables without affecting entries in the
   image buffer.  Adjusts a <b>linear transform function in zero point
   and slope</b>.  The appearance on the screen of the result of
   <kbd>contrast</kbd> is identical to specifying the <kbd>MIN</kbd> and
   <kbd>MAX</kbd> parameters in <kbd>ctvscl,</kbd> although the means by
   which this is achieved is different.  The cursor must be placed in the
   current active window.  </p>

<ul>

   Note that on 8-bit monitors, changes in the color tables apply to
   <em>all</em> image display windows.  In order to compare images
   with different ranges of values, load them using <kbd>ctvscl</kbd>
   or the equivalent with <em>different low/high windowing cuts</em>
   or with non-linear transforms (see below) before using <kbd>
   contrast</kbd>.  Color tables adjusted by <kbd>contrast</kbd>
   remain in effect unless they are explicitly reset (e.g. by using
   the <kbd>loadct</kbd> command).  If a new image looks strange, it
   may be because you have forgotten to reset the color tables.</p>
   
   You can "flip" the color table using the mouse buttons during <kbd>
   contrast</kbd>. </p>

    Note that the type of linear transformation between the image
   value and the display value adjusted by <kbd>
   contrast</kbd> is only <em> one of a very large
   set of possibly useful transformation functions.</em> You may want
   to experiment with various logarithmic, powerlaw, segmented, and
   other types of transforms to find the best display for your image.
   </p> 

   The "color-map adjust" feature in <a href="#ATV">ATV</a> is similar
   to <kbd>contrast</kbd>. </p>

</ul>

<li><kbd>refscl...</kbd> : A MOUSSE routine which displays a reference
   scale for the current color tables.  Shows the response of the
   display to a buffer containing a linear range of values between 0
   and 255.  Setting keyword <kbd>over</kbd> places the scale in the
   current window.  Useful when making fine adjustments in color
   tables and in making images for publication.</p> 

   END OBSOLETE SECTION -->

<u><b>Color Table Commands</b></u></p>

<ul>

The command to change ("load") the stored color table is
<kbd>tvlct,R,G,B</kbd>, where you must have defined the three
vectors beforehand.</p>

<ul>
To capture the current color table to vectors (e.g. to inspect them
or as a basis for revising them), use
<kbd>tvlct,rr,gg,bb,/get</kbd>.</p>
</ul>

A set of 41 predefined color tables is supplied with IDL; these can be
loaded with the <kbd>loadct,N</kbd> command, where N runs from 0 to
40.  The default gray-scale is loaded by the command
<kbd>loadct,0</kbd>.</p>

<ul> You can sample and load the supplied tables in a GUI using the
intrinsic routine <kbd>xloadct</kbd>. </p>

You
can examine the correspondence between color and index using David
Fanning's <kbd>cindex</kbd> routine. </p>
</ul>


On most 8-bit monitors, the display will <b>automatically update</b>
whenever the color table is changed (at a <kbd>loadct,N</kbd> command,
for instance).  However, <b>on 24-bit monitors you must reload the
image</b> in order for the change in color table to take effect (even in
emulated pseudo-color mode).  </p>

A variety of tools is available for adjusting the supplied color
tables or creating new ones.  These include <kbd>xloadct</kbd>,
<kbd>xpalette</kbd>, <kbd>stretch</kbd>, and David Fanning's 
<kbd>xcolors</kbd>.  </p>

A quick way to reverse the standard white-on-black color
table 0 to the <b>black-on-white</b> sense preferred by
astronomers, which is more sensitive to faint features, is the
following.  This would be useful to code as a procedure or script.

<ul>
      <p align=center> <pre> <kbd>  
              loadct,0
              tvlct,rr,gg,bb,/get
              rr=reverse(rr)
              tvlct,rr,rr,rr  </kbd>  </pre></p>
</ul>
</ul>


<u><b>Other Useful Display Commands</b></u></p>

<ul>

   <li>To display <b>logarithmically stretched images:</b>
       <kbd>ctvscl,alog10(image)</kbd>. Obviously, you need to
       insure that <kbd>image</kbd> does not contain zero or
       negative numbers.  A quick way to truncate low values 
       is to use the syntax 
       <kbd>alog10(image > k)</kbd>. where <kbd>k</kbd> is a scalar.  
       The notation <kbd>(x
       > y)</kbd> means "the maximum of the pair <kbd>x,y</kbd>."
       </p> 

   <li> Use a <b>pre-defined lookup table</b> to transform image
      values, e.g. to their logarithms.  Faster than actually converting
      values using the <kbd>alog</kbd> function.  E.g.: for integer image
      arrays with values in the range 0 to 1000, try this:</p> 

     <pre align=center> <kbd> 
            t=findgen(1000)  & t[0] = 1
            quiklog=alog10(t)

            ctvscl,quiklog(image)  </kbd> </pre> </p>
      <ul>

      <p>Note: In IDL, the form <kbd>array1(array2)</kbd> returns the values
      of <kbd>array1</kbd> in the elements specified by the values in
      <kbd>array2</kbd>. <kbd>array2</kbd> must be an integer or longword
      integer array.</p>

      </ul>

<!-- 
    <li>The same technique works with other forms of <b>nonlinear displays:</b>
      e.g. power laws with fractional exponents (0.3, 0.5) to
      increase dynamic range;  arcsinh, etc.  </p> 
-->



<a name="tvrd">
<li><kbd>cimage=tvrd([arguments])</kbd>:  Copy the contents of the active window
   image buffer into the variable <kbd>cimage</kbd>.  Be sure the
   desired window is <em>active</em> (e.g. by using <kbd>chan,N</kbd>)
   and that the window is <em>fully visible</em> on your terminal
   screen before calling <kbd>tvrd</kbd>.  </p> 

<ul>
    
   <kbd>tvrd</kbd> is useful in preserving the appearance of an display
   after you have manipulated the input image or color table or
   annotated the display; it is a basic tool in routines that 
   make hardcopies of graphics displays.  However, this is a
   case where <b>behavior is determined by the visual class of your
   graphics display</b>.  </p>

   <b>8-bit pseudo-color</b>:  The window buffer contains a 2-D byte
   image, which is copied by the command <kbd>cimage=tvrd()</kbd>.
   Note the empty parentheses (if you wish to copy the whole window).
   In this case, <kbd>cimage</kbd> is the 2-D byte-scaled image output
   by the last call to the <kbd>tv</kbd> or <kbd>tvscl</kbd> routines. 
   If you also save the current color
   table with <kbd> tvlct,rr,gg,bb,/get</kbd>, you can later reproduce
   the appearance of the display with the commands</p>

   <ul><pre>
            <kbd>tv,cimage</kbd>
            <kbd>tvlct,rr,gg,bb</kbd>  </pre>
   </ul>

   You could make a permanent copy of the display in a GIF file with
   the command <kbd>write_gif,'copy.gif',cimage,rr,gg,bb</kbd>.
   With a gray-scale color table, the array <kbd>c2image=rr(cimage)</kbd>
   will reproduce what you saw on the screen.  
   </p>

   <b>24-bit emulated pseudo-color or true-color</b>:  The window
   buffer contains a 3-D image, which is copied by the command
   <kbd>cimage=tvrd(true=N)</kbd>.  Here, the <kbd>true</kbd> keyword
   (values 1-3) determines over which dimension in the resulting array
   color will be interleaved.  The appearance of the
   display can be reproduced with the command <kbd>tv,cimage,true=N</kbd>.
   You could make a permanent copy of the display in a JPEG file
   with the command <kbd>write_jpeg,'copy.jpg',cimage,true=N</kbd>.
   Because JPEG is a "lossy" format, the copy will not be exact;
   if you need an exact version (that could be read back into a later
   IDL session), you can store in <b>TIFF</b> format.</p>

   In 24-bit <kbd>decomposed=0</kbd> mode, the color tables were used
   to create the 3-D display image, but you cannot "back them out" of
   <kbd>cimage</kbd> in order to recover the 2-D byte version that was
   created by the original <kbd>tvscl</kbd> command.  You can,
   however, create a 2-D image that approximates the original version
   as follows:  <kbd>newver=color_quan(cimage,N,rr,gg,bb)</kbd>.
   Here, <kbd>rr,gg,bb</kbd> represent the <em>output</em> color table
   needed for a proper display of the 2-D <kbd>newver</kbd> array.
   You can redisplay the new image or save it and the color table in
   GIF format. </p>

   David Fanning's <kbd>tvread</kbd> is a more elaborate,
   device-independent version of the <kbd>tvrd</kbd> function for
   8- and 24-bit monitors and optionally writes various types of output
   files. </p>

</ul>

<li><kbd>blink,windowlist</kbd> : blink between windows.  Windowlist
   is a vector containing numbers of windows to blink (in order).  E.g.
   <kbd>blink,[0,2,1]</kbd>.  To compare different exposures of the
   same field (e.g. two different filters), you will want to adjust
   the scaling of the two independently with <kbd>ctvscl</kbd> before
   calling <kbd>blink</kbd>.  To terminate, you must type in the
   command window, which may require you to use the window manager to
   bring it up.  Blink rate is adjustable.  </p> 
      
<li><kbd>tvbox...; tvcircle...; tvellipse...;</kbd> etc : draw various
   shapes in active window, e.g. to locate point sources identified by
   other routines.  To remove these, you must re-load the image in the
   window.  Adjust the color or darkness of the overlays by using the
   <kbd>color</kbd> keyword.  </p> 

<li><kbd>xyouts... :</kbd> write text to active window.  A variety of
   fonts is available. To remove previously-written text, you must
   re-load the window.</p> 

<li><kbd>curs,type</kbd> : select graphics cursor type </p> 

<li>To read the cursor position on an active window: use
the <kbd>cursor</kbd> routine.</p>


<li><kbd>set_plot,[device-name]</kbd> : allows you to change the
   current output device.  Normally, you will be using X-windows
   graphical output, for which the command is <kbd>set_plot,'x</kbd>.
   (This will be set by default when you begin your IDL session.)  
   The only other output device type you would commonly
   deal with is a PostScript file.  You can switch output to a
   PostScript file by typing <kbd> set_plot,'ps </kbd>.  Return to
   X-windows by typing <kbd>set_plot,'x </kbd>.  (The <kbd>chan</kbd>
   command automatically returns you to the X-windows default.)  You
   can determine the currently assumed device parameters by typing
   <kbd>help,/dev</kbd>.  <kbd>set_plot</kbd> supports a number of
   other devices as well (see the IDL manuals).<p> 

</ul>

<u><b>Object Graphics Image Display Software</b></u></p>

<ul>

The descriptions above are for the basic IDL <b>"direct graphics"</b>
display commands but outline the considerations underlying any image
display system.  IDL also offers a device-independent <b>"object
graphics"</b> programming mode, which is the basis for making more
elaborate GUI displays.  You need some experience with IDL before
attempting to do your own object-oriented programming.  However, a
number of GUI applications are publicly available:  e.g. the supplied
"Workbench" environment and the <kbd>iImage</kbd> display tool; Liam
Gumley's <kbd>imdisp</kbd>; and David Fanning's <kbd>tvimage</kbd>.
You ought to explore these and consider their strengths and
weaknesses.  Most such tools are not oriented toward astronomical
images.  The important exception, <kbd>ATV</kbd>, is described in the
<a href="#ATV">next section</a>.</p>

</ul>

<u><b>References on Image Displays</b></u></p>

<ul> Eventually, you may want to read more than is here
about image display techniques, though I recommend that new users just
plunge ahead and experience success and failure on their own first.  A
good introduction to color displays in IDL is David Fanning's <a
href="http://www.dfanning.com/color_tips/working_with_color.pdf">
"Working with Color"</a> writeup.  Also see his <a
href="http://www.dfanning.com/documents/tips.html">"Color Tips"</a>
page.  The basic Exelis introduction is Chapter 5 "Graphic Display
Essentials" in the <pub> Using IDL</pub>
manual.  More details on image displays and use of color can be found
in the on-line help system under "IDL Tutorials/IDL Display Concepts";
the examples mostly involve full-color image formats (e.g. JPEG, TIFF,
PNG).  The v7.0 <pub>Image Processing</pub>
manual covers image transformation techniques of interest more in
geoscience and medicine than astronomy.  For general background on
specifically astronomical image processing, see T. A. Rector et al.,
"Image-Processing Techniques for the Creation of Presentation-Quality
Astronomical Images," AJ, 133, 598, 2007; and R. Lupton et al.,
"Preparing Red-Green-Blue Images from CCD Data," PASP, 116, 133,
2004.  </p>

</ul>

<!-- NOTE: the v6.1 (2004) "Image Processing" manual contains much
more basic info in Chaps 1-3 about image display than does the current
v7 manual (2007).  Where is the information covered in the v6.1 manual
Chap 2 "Creating Image Displays" and Chap 3 "Working With Color"?
 8/17:  discover that much, not all, of it is in Chapter 5 of the v7
"Using IDL"; but reader is referred to the "Reference Guide" for
operation of programs like XPALETTE; don't know whether full example
discussion is given there.  Need to check full details of
correspondence.  The RefGuide contains at least some of the examples
in the v6.1 manual; e.g. under "REFORM" the manual shows how
true/indexed color images are related and shows examples of displays.
More examples are on the online help system:  IDL Users' Guides 
=> IDL Tutorials => Display Concepts => Displaying Images &
working with color.     

-->



<p><br></p>

<hr>

<h2 align=center> <a name="inspect"> 6.  DATA INSPECTION & MANIPULATION </a> </h2>

<p><a href="#contents"> [Up to Contents]</a></p>

The tools described here are oriented toward analysis of 2-D images, but most
are useful for any type of data array.  </p>


<u><b>Array Manipulation:</b></u></p>

<ul>

<li> You can operate on image arrays using any IDL
routine which accepts 2-D inputs, including the full range of standard
arithmetic and other mathematical functions.  Most such routines are
<b>array-oriented</b> and do not require you to worry about do-loops or
element structure in arrays.   </p>

<li>  Most IDL mathematical
functions behave sensibly and give you the results you intuitively
expect.  E.g. if <kbd>a</kbd> and <kbd>b</kbd> are arrays with the
same dimensions, then <kbd>c = a*b</kbd> produces an array with the
same dimensions in which each element is the product of the
corresponding elements in <kbd>a</kbd> and <kbd>b</kbd>.  (There are
separate operators--<kbd>#,##</kbd>---for other types of matrix
multiplication.)</p>

<li> Many kinds of image manipulation can be executed with one-line
commands in IDL.  E.g.:</p>

<ul>

Edge detection:  <kbd>ctvscl, a-shift(a,1,1)</kbd>  </p>


Unsharp masking:  <kbd>ctvscl, a-smooth(a,k)</kbd> displays the difference
between the original image and a boxcar-smoothed version with a smoothing
length of <kbd>k</kbd> pixels.  This is fast, but the smoothed image includes
the effects of any sharp structures (like stars).  Better, though slower to
execute, is <kbd>ctvscl, a-median(a,k)</kbd>. </p>

</ul>


<li> Changes are, of course, made to the temporary data sets stored
in RAM.  The original files from which the data were transferred into
your IDL session are not affected (unless you call special file
manipulation routines).  However, this also means that permanent
versions of the modified images are not kept at the end of your IDL
session unless you deliberately <kbd>save</kbd> the dataset or
<kbd>write</kbd> new output files (see <a href="#store">next section</a>).</p>

<li> If you want to maintain the applicability of the image
<em>header</em> to the manipulated image, then you must <b>update the
header</b> after each change.  You can add comments to the existing
header by using the <kbd>sxaddhist</kbd> routine.  Changes which don't
affect the <em>keywords</em> included in the header (e.g. sky
subtraction, excision of foreground stars) can be simply documented
this way.  However, changes in the flux scale or, especially, the image
format (through extraction, rotation, rebinning, etc) usually require
that the keywords be changed in order that later routines will function
properly.  A special set of AstUseLib routines, including
<kbd>hextract, hrot, hastrom, hrebin,</kbd> etc.  will do standard manipulations
on images and image headers simultaneously.  Astrometric information, for
instance, will be preserved.  </p>

</ul>


<u><b>Data Inspection:</b></u></p>

<ul>

<li><kbd>print,max(a); print,min(a); print,minmax(a); print,mean(a);
print,variance(a); print,median(a); print,moment(a)</kbd>: print
various statistical properties of image array.  (<kbd>moment</kbd>
prints first four moments.)</p>


<li> <b>To estimate the background level,</b> use <kbd>sky</kbd>.</p>

<ul>

<kbd>sky</kbd> works by estimating the <b>mode</b> of the image values.
It therefore assumes there are many more pixels near the sky background
level than there are source pixels.  It will <u>not</u> work well in the
case of very low sky backgrounds where the sky histogram is not 
smoothly continuous.</p>

</ul>


<li><b>To extract and examine a subarray</b>, you can use standard IDL
   subscript notation.  E.g.
<ul>
   <p align=center><pre>
     <kbd>part=image[100:200,150:250]</kbd></pre> </p>

    extracts a 101x101 subarray from the image. You can interactively
    determine the edges of an area of interest using <kbd>curval</kbd>
    or <kbd>cursor</kbd>.</p>

</ul>

<li><b>To enlarge (or compress)</b> an array:
   <kbd>new=rebin(image,N,M)</kbd>.  <kbd>N</kbd> and <kbd>M</kbd>
   must be integer multiples of the current dimensions of
   <kbd>image</kbd>. Compression is often needed with images which are
   too large to fit on your monitor (typically limited to about
   1000x900).  Packages like <kbd>ATV</kbd> and <kbd>SAOimage</kbd> do
   this compression automatically.</p>

<ul>

   For magnification, add the keyword <kbd>/sample</kbd> if you want to
   preserve the original pixel structure.  This substitutes nearest
   neighbor sampling for the bilinear interpolation which is the
   default. </p>

   To regrid an image to non-integer multiples of its original format,
   use <kbd>frebin</kbd> or <kbd>congrid</kbd></b>

   If you intend to make flux measures from the compressed or expanded
   images, <u>be sure to scale the result so that flux is
   conserved</u> in a given region of the original image.  For
   example, if you use <kbd>rebin</kbd> to compress an MxM image to an
   NxN image using <kbd>sample=0</kbd>, each pixel in the resulting
   image will contain the <u>average</u> of the corresponding pixels
   in the original, so that the total flux is a factor of
   k<sup>2</sup> smaller than in the original, where k=M/N.  </p>

</ul>


<li><b>Flagging values</b> in given range:  use the <kbd>where</kbd>
   function.  E.g.:  to highlight pixels containing a -666 flag:</p>

<pre align=center><kbd>

       tx=image          ; create temporary copy (unless you don't 
                         ;   mind corrupting the original array)
       finder=where(tx eq -666) ; create a list of relevant pixels
       tx[finder]=10000  ; highlight them (we assume normal tx values
                         ;   are << 10000)
       ctvscl,tx,min=0,max=9000  ; flagged pixels will now stand out
   </kbd></pre></p>



<li><b>To convert coordinates between decimal and sexigesimal form</b>,
use <kbd>sixty</kbd> [decimal to sexigesimal], <kbd>ten</kbd> [sexigesimal
to decimal], or <kbd>radec</kbd> [RA and DEC from degrees to sexigesimal].
For instance:</p>

<ul>

<center><kbd> radegrees=15.0*ten(22,30,17.5)  </kbd></center></p>

</ul>
</ul>


<u><b>Special Displays and Plots</b></u></p>

<ul>


<li><b>To plot an entire column:</b> <kbd>plot,image[N,*]</kbd>; to plot
values between rows <kbd>r1</kbd> and <kbd>r2</kbd> in a column:
<kbd>plot,image[N,r1:r2]</kbd>.</p>

<li><b>To plot a row:</b>  <kbd>plot,image[*,N]</kbd>.</p>

<li><b>To interactively select & plot rows or columns with the cursor:</b> try
<kbd>profiles.</kbd> </p>

<li><b>To plot the mean</b> of 5 adjacent columns:
   <kbd>plot,avg(image[c0:c4,*],0)</kbd>.  For 5 adjacent
   rows:  <kbd>plot,avg(image[*,r0:r4],1]</kbd>.</p>

<li><b>To extract an image slice</b> with arbitrary start and end
   points (selected by the cursor from the active window and marked
   with a "rubber band"):  <kbd>slice=profile(image)</kbd>.  You can
   then plot the extraction. </p>

<li><kbd>curval,image</kbd> : read off image values in each pixel
   interactively with cursor in current window.  To convert to
   fluxes, RA, DEC using information from the image header, use
   <kbd>curval,hdimage,image</kbd>, where <kbd>hdimage</kbd> is
   the associated header variable.  The intrinsic IDL routine
   for reading off image values is <kbd>rdpix</kbd>.</p>

<li><kbd>tvlist,image</kbd> : prints a matrix of image values in
   vicinity of cursor location in current window.  Options to write to
   file.  <kbd>imlist</kbd> is similar, but coordinates are typed in
   (does not use the window/cursor).</p>

<li><kbd>zoom</kbd> : displays an enlarged segment of the image in the current
   window centered on the cursor.  Middle mouse button changes zoom
   factor.  Right button exits.  Works by copying the currently displayed
   window buffer, not original image values, and the current version
   works only for pseudo-color displays.   Zoomed window vanishes
   on exit.  Keyword <kbd>/continuous</kbd> can be used to follow the
   motion of the cursor. </p>

<li><b>Image smoothing</b> is often useful in dealing with low 
contrast or noisy data.  Various options are available in IDL;
most widely used are <kbd>smooth</kbd> and <kbd>median</kbd>,
which yield the boxcar average and median values, respectively. </p>

<ul>
 To display an image smoothed by a 5x5 pixel boxcar in one line:
         <kbd>ctvscl,smooth(image,5)</kbd>. </p> 
</ul>

<li><kbd>surface,image</kbd>: produces surface plot (projected 3-D) of image.
   See the IDL
   manuals for many enhancements available in surface plotting
   (e.g. <kbd>shade_surface</kbd>).<p>

<li><kbd>plothist,image</kbd>:  evaluate histogram of pixel values in
   the image and plot the result.  The default histogram runs from the
   minimum to the maximum of the array with a bin size of 1.0 unit.
   You need to restrict the <kbd>xrange</kbd> when the array contains small
   numbers of real or erroneous values which are very large or very
   small.  By default it is assumed that the array contains integer
   values.  Optional parameters adjust cutoffs and binning.  The
   <kbd>histogram</kbd> function evokes strong emotions; to delve more
   deeply, see 
   <a href="histogram_tutorial-JDSmith.html"> 
   "Histogram: The Breathless Horror and Disgust"</a>, a tutorial by J.  D. Smith.
   </p>

<li><kbd>contour,image</kbd>:  plot a contour diagram.  To specify the contour
   levels, use the <kbd>levels</kbd> keyword.  E.g. to plot 10 contour
   levels at values of 25, 50, 100, 200...:</p>

<ul>
   <pre align=center><kbd>
                   nup = findgen(10)
                   clev = 25.*2^nup
                   contour,image,levels=clev </kbd></pre> </p>

    For an example of placing a contour line plot over an image display,
    see the header of Liam Gumley's <kbd>imdisp</kbd> routine.</p>

</ul>
</ul>


<u><b><a name="ATV">The ATV Image Display & Inspection Tool</b></u></p>

<ul>

<li> <kbd>ATV</kbd> is an IDL GUI-based program written
by Aaron Barth which combines image display capabilities with many of
the image inspection tools just described.  It is intended for
astronomical imaging, and its appearance and behavior are similar to
<kbd>SAOimage</kbd> <a href="atvshot.jpg">(example here)</a>.</p>

<li> ATV is a quick and easy way of inspecting images (brightnesses, x
or y profiles, morphology, etc.), doing rough analysis like getting
FWHM's and aperture photometry of sources, and extracting RA,DEC
positional information from headers.  It is oriented toward optical/IR
images but will work on any kind of 2-D image data.  ATV is the
<b>best place to start</b> if you want to explore GUI-based IDL
displays for astronomy.  The code is publicly available, and you can
readily adjust default behavior if you so wish. </p>

<li> At UVa, ATV software is kept in <kbd>/astro/idl/atv</kbd> and is included by
default in your IDL path.  To invoke ATV, type <kbd>atv</kbd>.</p>

<ul>

<li> To display an existing IDL image array in ATV, type
<kbd>atv,image</kbd></p>

<li> To display an image directly from a FITS file on disk, type
<kbd>atv,[filename.fits]</kbd> or use the "File" pull-down menu.</p>

</ul>

<li> ATV allows zooming and roaming around images. (It automatically
compresses or extracts from images too large for the screen.)  You can
adjust the scaling of the image, e.g. with the "Min/Max" entry boxes, 
and select between linear, log, or asinh scaling.  You can
interactively adjust the zeropoint and contrast in the color tables
(set MouseMode to "Color" and drag the mouse over the image holding
down the left-hand mouse button).  </p>

<li>Using single keystrokes, you can display a row plot (<kbd>r</kbd>);
column plot (<kbd>c</kbd>); surface plot (<kbd>s</kbd>); 
contour plot (<kbd>t</kbd>); a histogram (<kbd>h</kbd>); or
local image statistics (<kbd>i</kbd>).  You can also quickly
make an extraction of a spectrum from a spectral image (<kbd>x</kbd>). 
 </p>

<li> The <kbd>p</kbd> command does aperture photometry (DAOPHOT-style,
with background subtraction) on a selected compact source, with optional
display of the radial profile of the source.  Photometry, including
FWHM's, can be saved to a file.</p>

<li> Image displays in ATV can be readily stored in PostScript, FITS,
JPEG, TIFF, and PNG output file formats.  You can label the display or
add overplots before output.</p>

<li> <u>ATV vs. SAOimage (ds9)</u>:  The defaults in ATV produce better
initial displays of UV/optical/IR images than those in SAOimage, and
the displays are easier to adjust.  The ATV inspection tools are not
found in SAOimage.  However, SAOimage supports the identification of
"regions" for extraction by other software and is more facile for
blinking two or more images and in making a quick RGB composite from
3-color imaging.</p>

<li> ATV Links (UCI)</p>

<ul>

<!-- 
<a href="http://cfa-www.harvard.edu/~abarth/atv/atv.html">General info (CfA)</a></p>
<a href="http://cfa-www.harvard.edu/~abarth/atv/instructions.html">Instructions on how
to use ATV</a></p>   -->


<!-- <a href="http://www.astro.caltech.edu/~barth/atv/"> -->

<a href="http://www.physics.uci.edu/~barth/atv/">General info</a></p>

<!-- <a href="http://www.astro.caltech.edu/~barth/atv/instructions.html"> -->

<a href="http://www.physics.uci.edu/~barth/atv/instructions.html">
Instructions on how to use ATV</a></p>

</ul>
</ul>


<b><u>Making synthetic images to test software</u></b>:</p>

<ul> 

You can instantly create test images with commands like
<kbd>test=findgen(512,512)</kbd>.</p>

Experiment with display/cursor routines using test images containing "hot
pixels," e.g.  <kbd>test=fltarr(512,512)+1000.  &
test[150,250]=20000.</kbd>, steps, gradients, and so forth. </p>

To create a 16-level "test pattern" of stepped, uniform 100x100
subimages with pixel values running from 0 to 240:</p>
<ul>
<pre><kbd>
patt=bytarr(400,400)
q=bytarr(100,100)+16
for i=0,3 do for j=0,3 do patt[i*100,j*100]=(i+4*j)*q
ctv,patt
</kbd></pre>
</ul>

Synthetic point sources can be 
created quickly by placing "hot pixels" where desired and then
<kbd>convol</kbd>-ving the result with a point spread function. </p>

IDL's random number generators can be very useful in
such applications.  For instance, to add Gaussian photon noise to an
array containing predicted photon counts:</p>
<ul>
<pre><kbd>
b=size(array)
noise=sqrt(array)*randomn(seed,b[1],b[2])
noisyarray=array+noise
</kbd></pre>
(Here, values per pixel in the input array are assumed to be larger
than ~30 counts.  Otherwise use the <kbd>poisson</kbd> keyword to
simulate photon noise.)</p>

</ul>
</ul>

<p><br></p>

<hr>

<a name="store"> <h2 align=center>   7.  DATA AND IMAGE STORAGE </a></h2>

<p><a href="#contents"> [Up to Contents]</a></p>

<p><a href="#retrieve"> [Up to Data and Image Retrieval]</a></p>


<u><b>ASCII Files</b></u></p>

<ul>

The best way to save small data sets (e.g. photometry output) is in
the form of ASCII files, since these are easily edited and transported
(see <a href="#asciifiles">above</a>).  A sample script to write a
file containing target names, coordinates, and brightnesses might look
like the following:</p>

   <pre align=center><kbd>
       get_lun,unit
       openw,unit,'OutputFile'
       form='(a15,3x,f9.5,3x,f9.5,3x,f6.2)'
       for i=0,numtarg-1 do printf,unit,format=form,$
               targid[i],radeg[i],decdeg[i],vmag[i]
       close,unit
 </kbd></pre> </p>


Note: you can check the output formatting by doing a test print to your
terminal, using statements like:</p>


   <pre align=center><kbd>
       form='(a15,3x,f9.5,3x,f9.5,3x,f6.2)'
       for i=0,numtarg-1 do print,format=form,$
               targid[i],radeg[i],decdeg[i],vmag[i]
    </kbd></pre> </p>

<kbd>forprint</kbd> is a handy AstUseLib utility for printing several vectors
to either the screen or an ASCII file; the <kbd>format</kbd> keyword need not
be specified.</p>

</ul>


<u><b>Binary Files</b></u>:  See description of binary files <a
href="#binfiles">above</a>.  The basic IDL routine for writing
unformatted binary files is <kbd>writeu</kbd>.  To create files that
are portable between computer operating systems, use the optional
<kbd>xdr</kbd> keyword with the <kbd>open</kbd> procedure.  
</p>


<u><b>FITS files</b></u>:
To write a FITS file from IDL variables, use
    <kbd>fits_write</kbd>.</p>

<ul>

<kbd>fits_write,[filename],[image variable],[header variable]</kbd>:
Write images to disk in FITS format.  The resulting file will have
the name [filename].fits.  </p>


    If the images have been
    manipulated and you did not employ the AstUseLib header-tracking
    commands such as <kbd>hextract, hrot, hastrom, hrebin,</kbd> and
    so forth, then you must create a new header (use <kbd>mkhdr</kbd>)
    or update the existing one to properly match the stored image.
    <kbd>fits_write</kbd> will optionally produce a simple header, or you
    can use the <kbd>sx*</kbd> commands, such as <kbd>sxaddhist</kbd>
    or <kbd>sxaddpar</kbd> to do this. It is particularly important to
    be sure that the parameters <kbd>BITPIX, NAXIS*</kbd>, and
    <kbd>DATATYPE</kbd> are properly entered.
    <kbd>fits_write</kbd> writes to the current
    directory.</p>

<!--   (Although headers in FITS are
    ASCII files, they cannot be edited with standard text editors
    because of blocking conventions.)   -->

</ul>

<u><b>SDAS or IRAF files</b></u>: Use <kbd>stwrt</kbd> and
     <kbd>irafwrt</kbd>, respectively.  These (deprecated) routines
     each produce two output files (<em>*.hhh</em> and <em>*.hhd</em>
     for SDAS; <em>*.imh</em> and <em>*.pix</em> for IRAF). </p>

    <!--  File
     transfer between FITS, SDAS, and IRAF formats can be troublesome,
     since not all modes have been carefully tested.  This is true in
     both IDL
    and IRAF/STSDAS.  <b>Always check results to be sure.</b> </p> 
    -->

<u><b>Other image formats</b></u></p>

<ul> 
    Output in other popular, but not specifically astronomical, image
    file formats is supported by IDL.  See <kbd> write_gif,
    write_jpeg, write_png, write_tiff,</kbd> etc.  An alternative is
    <kbd>write_image</kbd>, an intrinsic IDL procedure that also
    writes output files in such formats.  IDL also supports writing
    MPEG animations.</p>

    See the description above on
    how to use <a href="#tvrd">tvrd</a> to copy the contents of a
    displayed image window to an IDL variable in preparation for
    writing to a file.</p>

    GIF format is a good way to store line graphics or processed
    images (in 2-D format) with special color tables embedded. JPEG,
    which stores images in 3-D format, is a natural means to save
    true-color images, though the compression algorithm used to reduce
    the file size may compromise quality (this can be adjusted).  TIFF
    files store images in 3-D format in lossless form; they are used
    for publication-quality images.  GIF and JPEG are the most widely
    used default formats for Internet browsers.  Unfortunately,
    neither of these, nor the other popular commercial formats,
    provide a way to save header information.</p>

</ul>

<u><b>Instant Storage of Session Data</b></u></p>

<ul>

    The intrinsic IDL <kbd>save</kbd> command will <b>save variables and
    programs from the current session</b> in a specially structured
    binary file.  All this material can be <b>restored in a later IDL
    session</b> with a single <kbd>restore</kbd> command.  </p>

    You should <b>delete all redundant or otherwise uninteresting variables
    (especially large arrays) before calling <kbd> save</kbd>.</b>
    Review the <kbd>save</kbd> keywords before use.  On a LINUX
    system, the output file will be in a universal <em>XDR</em> format
    which can be ported to non-LINUX computers.  </p>

     <kbd>save</kbd> can be very useful for storage of intermediate
    results but <em>is not recommended for permanent records</em>.
    Why? For one thing, it's too easy to forget what all the variables
    mean; if you take the time to write FITS or ASCII files, you
    are more likely to document the work.  For another, <kbd>
    save</kbd> encourages soaking up mass storage with redundant
    copies of arrays which may be only slightly changed from their
    original values.  It is more efficient to create a
    <em>script</em> which makes relatively simple changes to images in
    preparation for further processing rather than
    to store the intermediate versions.  Finally, the restoration of
    <kbd>save</kbd> files depends on the availability of IDL---not
    guaranteed if you move somewhere else.  Standard IDL FITS or ASCII
    file-writing routines are preferable for permanent data.</p>

     The default name of the output file is <em>idl.dat</em>,
    and this file name will be overwritten on the next <kbd>
    save</kbd>.  Best to change to something informative like
    <em>ngc1068.sav</em>.</p> 

</ul>

<p><br></p>

<hr>

<a name="phot"><h2 align=center> 8.  IMAGE PHOTOMETRY </a></h2>

<p><a href="#contents"> [Up to Contents]</a></p>

<ul>
<li>Native IDL lends itself to no-frills <b>rectangular aperture photometry</b>
through simple commands such as
<kbd>mean=total(array)/n_elements(array)</kbd>, where <kbd>array</kbd>
is a piece of a larger image (defined, for example, using the simple
index notation: <kbd>array=bigarray[x1:x2,y1:y2]</kbd>).  Refined
versions of this simplest approach may be found in <kbd>avg</kbd>. </p>

<li><b>Point Source Photometry: </b> </p>

<ul>

The AstUseLib contains an IDL
version of the DAOPHOT 1987 FORTRAN release, described at <a
href="http://idlastro.gsfc.nasa.gov/contents.html#C2">
http://idlastro.gsfc.nasa.gov/contents.html#C2</a>.  This performs
aperture photometry and PSF-fitting photometry on point sources.  It is
functionally very similar to DAOPHOT-87 but offers the added
versatility of the IDL interactive environment.  The basic routines
<kbd>find</kbd> and <kbd>aper</kbd> are especially useful.  The IDL
source code is available.</p>

These routines do not include the improved
features of the DAOPHOT 1991 or later releases.  To do PSF-fitting
deconvolution of blended images, you can try the IDL package <a
href="http://www.bo.astro.it/~giangi/StarFinder/index.htm">StarFinder</a>
or use the more recent stand-alone DAOPHOT or DOPHOT releases.  The
basic IDL routines remain very useful in preliminary assessment of data
frames, prior to setting loose the mechanical scroungers, and in
analyzing the results.  (The output files of standard photometry
programs can easily be read back into IDL.)  IDL is also an excellent
way to create synthetic data sets with known properties on which to
verify photometry package operation. </p>

</ul>

<li><b>Surface Photometry:</b> A number of basic routines such as
<kbd>dist_circle</kbd> and <kbd>dist_ellipse</kbd> are available to
support surface photometry, but there are no "official" AstUseLib surface
photometry programs.  Several individual users, including RWO, have
their own routines which others may use on an "at your own risk" basis.</p>

<li> The <b><a href="#ATV">ATV image viewer</a></b> contains an
interactive circular aperture photometry utility, derived from
DAOPHOT, which is very useful for exploring fluxes, FWHM's, and
backgrounds of selected compact sources.  ATV makes optional source profile
displays.
 </p>

<li>A number of other user-written <b>photometry packages</b>, mostly
for point sources, are available through the AstUseLib site.</p>

<!--   (at <a
href="http://idlastro.gsfc.nasa.gov/idlfaq.html#B4">
http://idlastro.gsfc.nasa.gov/idlfaq.html#B4</a>.)  </p>
-->

</ul>

<p><br></p>


<hr>

<a name="dbase"><h2 align=center> 9.  DATABASE ACCESS  </a></h2>

<p><a href="#contents"> [Up to Contents]</a></p>

Thanks to the efforts of Don Lindler, Wayne Landsman and others at
GSFC, <b>the IDL Astronomy User's Library offers convenient and
powerful access to on-line databases</b>. Information from
these can be directly incorporated into your IDL sessions.
For instance, the routine
<kbd>imdbase</kbd> marks the locations of sources in selected
catalogues on your current image display (assuming you have accurate
astrometry for your image.)</p>

Individual commands in the database
package are described on the <a
href="http://idlastro.gsfc.nasa.gov/contents.html#C3"> IDL Astronomy
User's Library home page</a>.  More details are given in the 2001
description <a
href="AUL-database-info-2001.pdf">
AUL-database-info-2001.pdf</a>.</p>


The databases must have been put in a special IDL-readable format
before you can access them (commands to do this are part of the
package).  A selection of IDL databases of general interest is publicly
available from the <a
href="http://idlastro.gsfc.nasa.gov/ftp/zdbase/">IDL Astronomy User's
Library</a>.  At UVa, approximately 95 such databases, weighted toward
UV science, are available.  They are presently linked to:
<kbd>/astro/idl/zdbase</kbd>.</p>

In order to use the databases, you must have defined the
environment variable <kbd>$ZDBASE</kbd> to point to the directory
containing them. </p>

To see what databases are available, use the command
<kbd>dbhelp,1</kbd>.  To see what information is
included in a given database and to display information for
selected entries (here numbers 10,100,1000), type</p>

<pre><kbd>   dbopen,'[data base name]
             dbhelp,1
             dbprint,[10,100,1000],'*
</kbd></pre>

To retrieve and use the data entries, you will need to
use the more sophisticated commands described in the
documentation cited above.  </p>

The creation of new databases using the provided tools is relatively
straightforward, so <b>you can convert other datasets to online
IDL databases</b> as you wish.</p>

<p><br></p>

<hr>

<a name="plots"><h2 align=center> 10.  PLOTS  </a></h2>

<p><a href="#contents"> [Up to Contents]</a></p>

IDL makes plots by default in the "current" terminal graphics window,
which can be adjusted in size, location, etc, by using the same basic
commands as for image displays (see <a href="#dispcommands">
above</a>).  Plots are scaled to the dimensions of the current
window.</p>

<p>The basic IDL commands for making plots are <kbd>plot</kbd>, for
creating a new plot, and <kbd>oplot</kbd>, for overplotting on an
existing plot.  The destination for the plot (terminal, PostScript
file, etc.) is determined by the <kbd>set_plot</kbd> command (see <a
href="#hard">next section</a>).  

<p>This, however, is only the tip of an immense iceberg.  IDL
contains many options for making plots---so many, in fact, that the
hardest part of the job can be keeping track of the multiplicity of
optional parameters.  Options in the form of <em>keywords</em> can be
specified in the calls to the plotting functions.  Alternatively, they
can be invoked in the form of
<em>system variables</em>, such as <kbd>!p.title</kbd>, which will
apply to all later plot calls until changed.  

<ul>

<li>Standard <b>plotting and graphics keywords</b> are explained in
Appendix B of the v7.0 <pub>IDL Reference
Guide</pub> or 
on-line by
typing <kbd>?plot</kbd> and then selecting "Graphics Keywords."
 </p>

<li> The most frequently used plotting keywords and system variables
follow.  All are optional.  Examples of use are given below. </p>

<ul>

<kbd>psym</kbd> or <kbd>!p.psym</kbd>: determines symbol type.  A
value of 0 (the default) produces a solid line with no discrete point
symbols; values 1 through 7 select other types of (unconnected)
symbols.  8 indicates that the user has defined a special symbol using
the <kbd>usersym</kbd> or <kbd>plotsym</kbd> procedures. 10 plots
in histogram mode. 9 is undefined.  To plot symbols connected by a
line, you can first <kbd>plot</kbd> with <kbd>psym=N</kbd>, then
<kbd>oplot</kbd> with <kbd>psym=0</kbd>. </p>

<kbd>xrange</kbd> and <kbd>yrange</kbd>: 2-element vectors giving the
minimum and maximum for each axis.  If not defined, autoscaling
will occur.  Corresponding system variables are <kbd>!x.range</kbd> 
and <kbd>!y.range</kbd>.</p>

<kbd>/xlog</kbd> and/or <kbd>/ylog</kbd>:  set these keywords to use
base-10 logarithmic plotting on the corresponding axis.  </p>

<kbd>linestyle</kbd>: selects style of line drawn (solid, dotted,
dash-dot, etc) if <kbd>psym=0</kbd>.</p>

<kbd>xstyle</kbd> and <kbd>ystyle</kbd>: set axis options (e.g.
exact range rather than rounded off)</p>

<kbd>!p.title</kbd>,<kbd>!x.title</kbd>, and <kbd>!y.title</kbd>:
strings for the plot title (centered
over upper x-axis), x-axis title, y-axis title. </p>

<ul>
(To annotate plots other than on the axes, use the <kbd>xyouts</kbd>
command.)</p>
</ul>

<kbd>font</kbd> or <kbd>!p.font</kbd>:  specifies the font to be used for
annotations.  The intrinsic IDL-supplied fonts are "vector-drawn
Hershey" fonts.  These are satisfactory for screen displays, are
device-independent, and are necessary when making 3-D plots.  But it
is better to use the "hardware" fonts supplied by graphics vendors for
publishable quality work.  Hardware fonts are associated with each of
the various supported output devices.  <kbd>!p.font=-1</kbd> (default)
selects the vector-drawn fonts; <kbd>!p.font=0</kbd> selects the
hardware fonts.  To choose a particular font, once you have selected
hardware-defined fonts, use the <kbd>device,set_font="[name]"</kbd>
command.</p>

<ul>
For help in selecting fonts, see the <kbd>showfont</kbd> (vector-drawn),
<kbd>xfont</kbd> (X-windows terminal), or
<kbd>ps_show_fonts</kbd> (PostScript) routines.  For X-windows,
you can also type  <kbd>xlsfonts</kbd> at
the LINUX prompt to obtain a list of available font names.
For more information on handling fonts in IDL, type <kbd>?fonts</kbd>.
 </p>

</ul>
</ul>
</ul>

<p>The IDL defaults are not as "nice" as those in SUPERMONGO, for
example.  However, you can quickly customize to obtain as
sophisticated a plotting style as you like.  All the functionality of
SUPERMONGO and other scientific graphics packages is inherent in
IDL. Many of the 2-D and 3-D graphics routines are illustrated in the
IDL Demos that come with the system.  </p>


<p>Color tables for plots:</p>

<ul>

The plot commands accept the keywords <kbd>background</kbd>, which
sets the background color of a plot, and <kbd>color</kbd>, which
determines the color used for lines and symbols.  By default on a
pseudo-color X-windows display, <kbd>background</kbd> is set to index 0
and <kbd>color</kbd> is set to index 255.  These therefore display the
"bottom" and "top" of your current color table, respectively.  [Color
tables are explained under <a href="#display">Image Display</a>.]  The
actual appearance of your plot will then depend on what color table
you have loaded (e.g. with <kbd>loadct,N</kbd>).  The default table
(<kbd>N=0</kbd>) produces a black background and white symbols.  Your
display will change if you use a different color table or
plot/background indices.  You can create a special set of color
tables to produce a defined set of, say, 10 standard colors for your
plots.</p>

Note: it's easiest to use pseudo-color or emulated pseudo-color
(<kbd>device,decomposed=0</kbd>) for plots.  In 24-bit true-color
(<kbd>device,decomposed=1</kbd>, you must specify colors
as longword integers. </p>

</ul>

<p><u><b>Sample plotting scripts</b></u> for displaying plots on your
terminal follow.  These involve a mixture of intrinsic IDL and
AstUseLib routines:</p>

<ol>

<a name="plot1"><li><b>Plot an analytic function</b>, using default
axis labeling.  </p>

<pre><kbd>
x=findgen(10000)/10.           ; Create the independent variable,
                               ;  here running between 0 and 1000
                               ;  in intervals of 0.1

y=x*sin(x/15.)                 ; Create the function of interest

plot,x,y                       ; Plot the function against the
                               ;  independent variable with a solid line. 
                               ;  Plot will appear in the current window
                               ;  (or Window 0 if none are open) with axes
                               ;  scaled to match the maximum x,y ranges.
                         
plot,x,y,xrange=[0,50]         ; Restrict plot to x values in range
                               ;   [0,50].  Y range automatically scaled.

plot,x[99:199],y[99:199]       ; Restrict plot to the 100th through
                               ;   200th elements of the arrays.

plot,x,y,xrange=[0,5],psym=1   ; Restrict plot to x values between
                               ;   0 and 5, and plot points separately
                               ;   as plus signs.

oplot,x,y                      ; Add continuous line plot to previous display,
                               ;   using existing axis scales

plot,x,1+y^2,/ylog             ; Plot a new function (defined to be positive
                               ;  definite), using a base-10 log scale on the
                               ;  y axis

</kbd></pre>


<a name="plot2"><li> <b> Plot galaxy surface brightness data </b>(in
magnitudes) with error bars versus radius to the one-quarter
power.</a> Use discrete symbols (not a connected line).  On this plot,
a galaxy with a standard "de Vaucouleurs" brightness profile will
produce a straight line.   This example also shows how one can quickly
edit bad data points out of plots.</p>

Assume that the (ordered) vectors <kbd>sb</kbd>, <kbd>rads</kbd>, and
<kbd>sberr</kbd> already exist, with <kbd>sb</kbd> and
<kbd>sberr</kbd> in units of ergs/s/cm^2/Angstrom/arcsec^2 and
<kbd>rads</kbd> in units of arcsec.  Assume that because of bad data
points you must truncate the plot to eliminate the first 3 entries and
those after the 20th. </p>

<pre> <kbd>

mags=-2.5*alog10(sb(3:19)) -21.1   ; Convert SB to magnitudes per arcsec^2
                                   ; in the STMAG system, ignoring bad data.
                                   ; Assumes all SB entries are > 0. 
                                 

r25=rads(3:19)^0.25                ; Compute fourth root of radius vector,
                                   ; ignoring bad data entries

magerr=1.086*sberr(3:19)/sb(3:19)   ; Convert uncertainties 
                                    ;   in SB to magnitudes

!y.range=[25,18]               ; Set a non-default y-axis range; in
                               ; this case the magnitude scale has 
                               ; smaller (brighter) values higher
                               ; on the y-axis

                               ; Make the titles

!p.title='Sample Surface Brightness Profile"
!x.title='Radius(arcsec)^0.25'
!y.title='Surface Bright (mags/arcsec^2)'

plotsym,4,1.5,/fill            ; Choose filled triangles for plotting symbol,
                               ;   50% larger than the default

ploterror,r25,mags,magerr,psym=8
                              ; Make plot on terminal screen with error bars; 
                              ; Psym=8 specifies a user-created symbol, which
                              ;    in this case was defined by plotsym.
                              ;    No connecting lines between points.
                              ; If psym were omitted or set to 0, no
                              ;    symbols would be plotted and the points
                              ;    would be connected by straight lines.

xyouts,1.5,20,'NGC 4151'      ; Add a label within the plot area.  The
                              ;    positional parameters (data units) set the 
                              ;    leftmost position of the displayed string.  
                              ;    Choose these so the string is clear of 
                              ;    the data and axes. 

</kbd> </pre>


<li><b> Make a contour plot</b> of a smoothed image.

<pre> <kbd>
chan,3                              ; Open plotting Window 3

!x.title='X'                        ; Make titles
!y.title='Y'
!p.title=' Contours for Image'

square                              ; Set aspect ratio to make a square plot
                                    ;   (Note that you must also give this command
                                    ;   after the PostScript device is called
                                    ;   when making hardcopies.)

smooth_one=smooth(image,5)          ; Smooth the image by a 5 pixel boxcar

clev=[10,20,40,80,160]              ; Define trial contour levels--assume
                                    ;     these values span the range of interest

contour,smooth_one,levels=clev       ; Do fast test of contour plot.  Check &
                                     ;   iterate clev for best appearance
 
contour,smooth_one,levels=clev,/follow  ; Do more accurate (slow) plot,
                                        ;  with labels
</kbd> </pre>

<a name="plot4"><li><b> Read, sort, and plot data from an ASCII file; make & display
trial polynomial fits </b></a>

<p> Assume <kbd>x</kbd> is a vector containing values in the range 0
to 5 and that <kbd>y</kbd> is the corresponding dependent variable.
Assume that these are to be read from an ASCII file named
<em>xy.dat</em>, which contains <kbd>x</kbd> and <kbd>y</kbd> in
separate columns.  <em>xy.dat</em> can contain an initial explanatory
section and other separator headers, as long as none of these contain
only one or two floating point numbers (since <kbd>readcol</kbd> will
mistake those for data lines).  The data columns need not be aligned.
By default, the <kbd>readcol</kbd> routine will read in the numerical
<kbd>x,y</kbd> data ignoring any line containing alphabetic
characters.  No labels are put on the plot in this example. 

<pre> <kbd>
readcol,'xy.dat',xx,yy         ; Read data from the file.  Note that a format 
                               ;    statement and 'open' command are not required,
                               ;    nor do xx and yy have to be pre-defined

index=sort(xx)                 ; Sort the arrays in order of increasing x 
x=xx(index)
y=yy(index)

chan,1                         ; Open Window 1 for plotting

plot,x,y,psym=5                ; Plot the data with open triangles

quadcoeff=poly_fit(x,y,2)      ; Derive coefficients for best quadratic
                               ;    polynomial fit
print,quadcoeff                ; Print these out (optional) [Note: 
                               ;    quadcoeff is a vector]

tx=findgen(101)/20.            ; Create independent variable vector for fitted
                               ;    values (uniform x interval of 0.05 units)

quadtesty=poly(tx,quadcoeff)   ; Create the fitted quadratic values

oplot,tx,quadtesty,psym=1      ; Overplot the quadratic fit with plus signs

cubcoeff=poly_fit(x,y,3)       ; Derive coefficients for cubic fit
cubtesty=poly(tx,cubcoeff)     ; Create the fitted cubic values

oplot,tx,cubtesty,psym=3       ; Overplot the cubic values with small dots

                               ; [Assume the quadratic fit was adequate]

delta=y-poly(x,quadcoeff)      ; Compute the difference between y data and
                               ;    the best quadratic fit 

nix=where(abs(delta) gt 2.)     ; Locate those y values which are more
                                ;    than 2 units from the best fit

weight=fltarr(n_elements(x))+1. ; Create a weight vector corresponding to
                                ;     x with unit entries

weight(nix)=0.0                 ; Give deviant points zero weight

newquadcoeff=polyfitw(x,y,weight,2) ; Derive improved quadratic coeffs. 
                                    ;   employing weights just assigned

final=poly(tx,newquadcoeff)         ; Create improved fit values

chan,2                         ; Open Window 2 for final, clean plot.
                               ; (Window 1 is retained for comparison.)

plot,x,y,psym=5,xrange=[1,3.5] ; Plot the data with open triangles in
                               ;    Window 2.  
                               ; Assume interest is limited to only 
		 	       ;    part of data x-range.

oplot,tx,final,psym=0          ; Overplot final fit with solid line
</kbd> </pre>


<li>  <b>Distinguish two samples in a histogram plot</b></p>


Suppose you have measurements of a quantity <kbd>val</kbd> for two samples
   of objects with a similar range of values and you want to compare
   the histograms of the two in a single plot.  A simple way to do
   this in IDL is to create the union of the two datasets for a first
   plot and then overplot a shaded histogram of the second set.  If
   the data consist of two vectors, <kbd>val1</kbd> and
   <kbd>val2</kbd>,</p>

<pre><kbd>
     allval=[val1,val2]
     plothist,allval,bin=0.2,xrange=[0,8]
     plothist,val2,bin=0.2,/over,/fill,fcolor=200
</kbd></pre>


In the resulting plot, the val1 entries will be unshaded, while the
 val2 entries will be shaded with the fill color value 200 (the
on-screen appearance will be determined by the pre-loaded color
table).  </p>

<ul> By default, <kbd>plothist</kbd> will plot the full range of
values in the data.  In histograms, this is often undesirable because
extreme values usually have small populations.  It is helpful to
restrict the range for better display of the important values; here we
used <kbd>xrange</kbd> to do that.</p>

</ul>

Similarly, in the case of a subset of data values that are to be
distinguished by some second parameter:</p>

<pre><kbd>
     plothist,val1,bin=0.2,xrange=[0,8]
     good=where(param ge 0) 
     plothist,val1(good),bin=0.2,/over,/fill,fcolor=200
</kbd></pre>

<ul>
  Here, the vector <kbd>param</kbd> must have the same length as
   <kbd>val1</kbd>, and we assume the subset of interest is defined by
   having a non-negative value of <kbd>param</kbd>.</p>
</ul>

</ol>

<p><br></p>

<hr>

<h2 align=center><a name="hard">    11.  GRAPHICS HARDCOPIES  </a></h2>

<p><a href="#contents"> [Up to Contents]</a></p>

<p>The most common method of obtaining hardcopies or permanent storage
of graphics output (plots or images) is to use <b>PostScript
files</b>, since these can be printed on most laser printers.
PostScript files can be later edited and reformatted, though special
(non-IDL) programs are needed.</p>

IDL also supports output of <b>GIF, JPEG, TIFF, PNG,</b> and other
file formats.  GIF and JPEG are standard for Internet Web browsers.
GIF is recommended for line-drawing and plot output storage.  TIFF is
recommended for high quality, full color reproductions (e.g.
transporting image files to vendors for hardcopies or publication).
</p>

<p>You should always experiment on the terminal screen with your plot
format before dumping to an output file.  It is easy to do this by
working out the set of commands you want while plotting to the screen,
then typing <kbd>set_plot,'ps</kbd> (in the case of PostScript output)
and <b>repeating the commands using the command recall buffer</b>.</p>

For more complex plots, use the <kbd>journal</kbd> utility, then edit
and re-execute the resulting file (or cut and paste across windows).</p>

<b>The <kbd>set_plot</kbd> command determines
which output graphics device you are using</b>.
The most common versions of this command are:</p>

<pre> <kbd>
        set_plot,'x</kbd>  :  Send output to X Windows (default) <kbd>
        set_plot,'ps</kbd> :  Send output to the PostScript file "idl.ps"
</pre>



<p>The subsequent commands for sending data to the PS file are
(mostly) the same as for putting data on your monitor screen, since
monitors and PS files are interchangeable output devices for IDL.

<p>You can always <b>check the properties of the current graphics
output device by typing <kbd>help,/dev</kbd>.</b> You can change
these defaults by using the <kbd>device</kbd> command.  The
hardware/software interfaces are sometimes non-trivial, and you will
want to plan for a significant learning curve in doing things which
are not "vanilla."  Before sending large jobs to printers, vendors,
etc., be sure to <em>check</em> the files using LINUX <kbd>ghostview,
xv,</kbd> or other screen display programs.  


<p>Here are some graphics output methods for common situations:</p>

<ul>
    
<li><b>To make a PostScript hardcopy of a <u>plot</u>.</b>  
    </p>

<ol>

<li> Type <kbd> set_plot,'ps </kbd> to send output to "idl.ps"</p>

<li> Optionally, make adjustments to the plot size, aspect ratio,
     orientation, lettering fonts, etc. using the <kbd>device</kbd>
     command</p>

<li> Give the set of plotting commands here---just as for a screen plot;
     all system variables will still be in force </p>

<li> Type  <kbd>device,/close</kbd> to close the file <em>idl.ps</em>.
     (Note: the PostScript file is not actually written to disk until
     the close command is given.)</p>

<li> Type  <kbd>$lp idl.ps</kbd> to print the file on the default printer.
      </p>

<li> The next plotting command will overwrite <em>idl.ps</em>.  If you
     want to save it, you must change its name.  E.g. 
     <kbd>$mv idl.ps bossplot.ps</kbd>. </kbd>   </p>

<li> <u>Example</u> (based on <a href="#plot2">continuing Plotting Example
     #2</a> under <a href=#plots>Plots</a> above.) </p>

<ul>

<pre><kbd>
set_plot,'ps                  ; Plot will be sent to PostScript file "idl.ps", 
                              ;     not to the screen
                 
                              ; Note that your definitions of plotsym and 
                              ;     system variables such as axis labels
                              ;     are still in force


!p.font=0
device,/helvetica,font_size=12 ; Use Helvetica PostScript font for labels

ploterror,r25,mags,magerr,psym=8
xyouts,2.5,17,'NGC 4151'
                              ; Make PS plot with error bars, adding the
                              ;    label inside the plot area
                             

device,/close                 ; Close PS file 

$lp idl.ps                    ; Send file to printer

$mv idl.ps surbriteplot.ps    ; Rename PS file to save it.

set_plot,'x                   ; Send further output to the terminal

cleanplot                     ; Reset the plotting system variables to defaults
</kbd></pre>

</ul>

<li> The output file will have the expected "black-on-white" sense, unless
you make use of the keywords described next.</p>

<li> You can make <b>color</b> PostScript files by setting
<kbd>device,/color</kbd> and using the
<kbd>background</kbd> and <kbd>color</kbd> keywords (see
the <a href="#plots">Plots</a> section). However, the treatment of
color tables differs from the X-windows case.  Consult the
IDL manuals. </p>

</ol>


<li><b>To make a PostScript hardcopy of a displayed <u>image</u></b>:
    use <kbd>tvlaser</kbd>.  This dumps a bitmap of the current window
    (using the <kbd>tvrd</kbd> utility) to a PostScript file and
    prints it on the default PS printer.  Various options add
    comments, information from the header, change the format, and so
    forth.  If you want to save the PostScript file, answer
    <kbd>no</kbd> to the query about "removing" it.  For color output,
    use the <kbd>colorps</kbd> keyword.  For true-color images, use
    the <kbd>truecolor=N</kbd> keyword. </p>

<ul> You can use <kbd>tvlaser</kbd> to copy a displayed plot
window.  This is handy for making quick working hardcopies of plots.
However, the resolution and appearance of the standard PostScript
output procedure described above will almost always be better. </p>

</ul>

<li><b>Other output formats</b>.  For image output in GIF, JPEG, TIFF,
PNG, and other popular output file formats, first capture the
displayed image using the <kbd>tvrd</kbd> command (see
<a href="#tvrd">above</a>).   You do not need to use the
<kbd>set_plot</kbd> command.  Simply send the captured image
to an output file using the appropriate <kbd>write</kbd> command.
David Fanning's <kbd>tvread</kbd>
program can dump an image and make an output file in one step
through use of keywords like <kbd>/jpeg</kbd>. 
 </p>

<ul>
   Tip: when producing PostScript output files of images for publication,
   it's useful to also make a GIF version, since this can be read back
   into IDL later if touch-ups are needed.  IDL cannot read PS files (though
   LINUX <kbd>xv</kbd> can convert PS's to GIF's). </p>
</ul>

<li><b>Output of large images</b>:  image output need not be confined to those sizes
you can display on your screen, as in the above examples.  Larger image
arrays can be written directly to files using the <kbd>write_gif</kbd>,
<kbd>fits_write</kbd>, and similar commands. 


<!--  Convert the image to
byte format before outputting using the <kbd>bytscl</kbd> command, as
in:</p>

<pre>
     <kbd>pic = bytscl(bigim,min=0,max=1835,top=255)</kbd>
</pre> 
-->

<!-- OBSOLETE

<li> Note: some slide-making software assumes that images will be in
LANDSCAPE mode---i.e. long axis horizontal.  If you are exporting
images intended for slides, it is easiest to adopt landscape mode
here.  If your image is significantly higher than wide, rotate it 90
degrees using one of the IDL utilities before saving it.  E.g.  <kbd>
picname = rotate(picname,3)</kbd>. </p>
-->


</ul>


<b>Technical Issues:</b></p>

<ul>

<p>PostScript files are the best way to get high quality line-drawing
    <u>plots</u> and are generally well treated by publishers.  Grayscale or
    color <u>images</u> are another matter, however, and should be approached
    in an iterative way.  A published PS image may look very different
    from the one you printed locally.  GIF or TIFF files may yield better
    results than PS.

<p>There can also be difficulties with the finite resolution of screen
   displays copied using the <kbd>tvrd</kbd> routine.  This is true
   for the quality of both the image and any lettering which may have
   been added to it.  On a typical computer screen, you will not get
   more than about 900x900 resolution.  However, a PostScript file at
   300 dpi can yield much higher resolution (1800x1800 in a 6"
   image). </p> 

<ul>

   As an alternative to the screen-capture <kbd>tvlaser</kbd>
   method described above, you can write images and labeling
   <em>directly</em> to a PostScript file using the standard <kbd>tv,
   tvscl, xyouts</kbd> and other routines.  The main difficulty is
   understanding the coordinate system used within the PS file and
   placing the various elements of an output page in the right
   positions.  People wind up using trial and error (easy by writing
   the PS file, then giving a <kbd>$ghostview [filename]</kbd> command
   from within IDL).</p>


</ul>
    
<p> If you store duplicates of your graphics output in GIF, TIFF, JPG,
    etc files, you can use non-IDL utilities like <kbd>xv</kbd>,
    <kbd>Gimp</kbd>, <kbd>Photoshop</kbd>, etc. to manipulate them
    further:  in size, rotation, contrast, color table, and by
    applying various image enhancements.  <kbd>xv</kbd> can convert
    GIF to PostScript and vice versa.  Especially useful for
    compressing image sizes for use on the Internet, the arXiv
    Preprint Server, and so forth.  </p>

   For more tips on making good PS graphics, see
   <a href="http://www.astro.caltech.edu/~kelle/figs.html">
   Making Figures with IDL</a> by Kelle Cruz and 
   David Fanning's  <a
   href="http://www.dfanning.com/documents/tips.html#PostScript">
   http://www.dfanning.com/documents/tips.html#PostScript</a></p>


</ul>

<p><br></p>

<hr>

<h2 align=center><a name="hints"> 12.  IDL HINTS AND ANNOYANCES </a> </h2>

<p><a href="#contents"> [Up to Contents]</a></p>

<p> Not many people have experienced <b>fully interactive
computing</b> before they start to use IDL.  There are tremendous
advantages but also many pitfalls for the unwary.  The pitfalls will,
of course, mostly seem obvious and trivial in retrospect---i.e. 
<b>after</b> you have learned to avoid them.  A number of tips & warnings for
IDL beginners are discussed in this section.  </p>


<u><b>Paths, Procedures, Directories</b></u></p>

<ul>

<li>If a <b>procedure name is unrecognized</b> or gives unexpected error
messages, check to be sure your directory path (<kbd>!path</kbd> inside IDL) is
set properly.  The initial value of <kbd>!path</kbd> is taken from the shell
variable <kbd>$IDL_PATH</kbd>.  Check the directories in the path for the
procedure.</p>  

<li> Unexpected behavior can also occur if you pick up the <b>wrong
version of a program</b> for which there are multiple copies in your
<kbd>!path</kbd>.  Two ways to check out possible mistakes of this
kind:  <kbd>print,file_which([program_name.pro])</kbd>; or <kbd>.run -t
[program name]</kbd> and inspect the listing of the program for
version information.  The <kbd>file_which</kbd> routine operates
like LINUX <kbd>which</kbd>.  If your <kbd>!path</kbd> does not
explicitly include the current directory (which is recommended,
see <a href="#setup">below</a>) then you should add the
<kbd>/include_current_dir</kbd> keyword. </p>


<li>The notation <kbd>:+/directoryname</kbd> in the
<kbd>$IDL_PATH</kbd> definition <b>expands the path</b> to include all
subdirectories of the named directory which contain <em>*.pro</em> files.  Use
<b>sparingly</b> to avoid picking up old versions of routines, which are
often stored in subdirectories of active versions.  </p>

<li>Errors will also occur if you try to <b>call a function as a
procedure</b> or vice-versa.  A procedure requires a
<kbd>[name],parm,...</kbd> call while a function requires a
<kbd>[var]=[name](parm,...)</kbd> call.  Use <kbd>help,/rou</kbd> to
keep functions and procedures straight.  If you try to execute a main
program by typing its name rather than by typing <kbd>.run [name]</kbd>, you
will receive an error message.</p>

<li>Remember that <b>data output will be written to the directory
which is current</b> when the output command was given.  If you use
<kbd>sd</kbd> frequently to move through directories, you may lose
track of where the output went (though a journal file can tell
you).  If you are currently in someone else's directory on which you
do not have write permission, the output commands will not function.
Some commands (e.g. <kbd>tvlaser</kbd>) can produce <em>large scratch
files</em>.
"Unrecognized file" errors during input commands often mean that you are
in the wrong default directory.  Check with <kbd>sd</kbd>.  </p>

<li>After modifying a <kbd>[name].pro</kbd> procedure file, <b>be sure to
recompile</b> it with <kbd>.run [name]</kbd> before attempting to use
it.  If the routine had been compiled before you modified it, simply
entering <kbd>[name]</kbd> will execute the OLD version.</p>


</ul>


<u><b>Special IDL Interactive Aids & Accelerators</b></u></p>

<ul>

<li>In programming, note the great usefulness of <b>interactive
aids</b> in intrinsic IDL. such as <kbd>size,
n_params, n_elements, keyword_set,</kbd> and others.  These allow
you to assess the state of the variables in your program at any time.</p>

<li><kbd>print</kbd> allows you to <b>print the current value of any
variable to the screen </b> at any time during an interactive session
(beware, however, in the case of large arrays).  A format statement is
optional.  Default formatting:  row vectors are printed across the
screen; column vectors, down.  <kbd>printf</kbd> 
is the corresponding command to print to an output <b>file</b>.  Both
commands can be used within programs. 
 </p>

<li> <kbd>readf</kbd> is the standard interactive command to 
<b>read data from an ASCII file</b>.  A format statement is optional.  The
same command can be used within programs.  To read input from the keyboard
from within a program, use the <kbd>read</kbd> command.</p>

<li> <kbd>readcol</kbd> is a handy AstUseLib utility for <b>reading in
ASCII files</b> of columnar data (see <a href="#readcol">above</a>).
A format statement is optional (depending on the content of the
files); lines containing unexpected characters are automatically
skipped.  For fixed-format ASCII I/O, see <kbd>readfmt</kbd> and
<kbd>forprint</kbd>. </p>

<li> IDL array-oriented mathematics often eliminates the need for
do-loops or index-specific programming, and you should <b>use
index-free notation</b> wherever possible.  (IDL is significantly
slower when data elements are referenced by indices.) </p>

<li> There are about 20 intrinsic IDL functions for <b>creating arrays</b> of
different types and filling them with initial values, including
<kbd>intarr</kbd>, <kbd>fltarr</kbd>, <kbd>indgen</kbd>,
<kbd>findgen</kbd>,  <kbd>replicate</kbd> and  <kbd>make_array</kbd>.</p>

<li> There is a large set of other <b>array-oriented arithmetic
functions</b>, such as <kbd>expand</kbd>, 
<kbd>rebin</kbd>, <kbd>reverse</kbd>, <kbd>smooth</kbd>,
<kbd>sort</kbd>, <kbd>total</kbd>, <kbd>transpose</kbd>,  and so forth.</p>

<li> You will find many uses for the <kbd>where</kbd>
function.  E.g. to find all non-positive values in an array in order
to prevent errors when taking logarithms, type <kbd>find=where(a le
0)</kbd>.  <kbd>find</kbd> will be a vector containing the indices of
the non-positive entries.  The subarray <kbd>a(find)</kbd> then will
contain all those points.</p>

<ul>

For example: to replace all values less than 1 in an array with 1,
type<br> <kbd>a(where(a lt 1))=1</kbd>.</p>

If, instead, you simply want a count of the number of entries
with values less than 1, type: </p>

<ul>

<kbd>find=where(a lt 1, count) & print count</kbd></p>

</ul></ul>

<li>  Another quick way to place a floor on elements in an array:
 <kbd>a = (a>1)</kbd> replaces all elements
with values less than 1 in array <kbd>a</kbd> with 1.
(The notation <kbd>a>1</kbd> means "an array containing the
maximum of 1 and the original elements of <kbd>a</kbd>".)  </p>




<li> The <a href="#recall">recall/edit</a> and <a
href="#journal"><kbd>journal</kbd></a> utilities are indispensable
means to iterating and recording IDL code.</p>


</ul>


<u><b>Definition & Stability of Variables</b></u></p>

<ul>

<li>Remember that the <b>first element</b> of vectors and arrays is
always at <b>index 0.</b> (This is to preserve the conventional axis
notation for plots.)  If <kbd>b</kbd> contains ten elements, element
indices run from <b>0 to 9, not 1 to 10</b>.  A reference to
<kbd>b(10)</kbd> is out of the vector's bounds.  This will kill a
subroutine, though it only generates an error message if it occurs on
the command line.  </p>

<li>If some previously defined <b>variables seem to have
"vanished"</b> or other peculiar behavior occurs, check (e.g. type
<kbd>help</kbd>) to see that you are in the main program and not a
subroutine.  See <kbd>retall</kbd> <a href="#retall">above</a>. </p>

<ul> To
return automatically to the main program whenever an error occurs in a
subroutine, enter <kbd>on_error,1</kbd> at the beginning of your IDL
session (strongly recommended except when debugging).  </p>
</ul>


<li><b>To create test arrays/vectors</b> in order to experiment with IDL
procedures, use <kbd>indgen, findgen</kbd>, etc.  For instance:</p>

<ul>

<kbd>a=findgen(100,100)</kbd> creates a 100x100 floating point array
with unique element values running between 0 and 9999.0.  </p>

<kbd>a=fltarr(100,100)+10.</kbd> creates a 100x100 array containing
10.0 everywhere.</p>

Create vectors with simple definition statements
like <kbd>z=[1,3,9,27]</kbd>; statements like <kbd>z=[z,81]</kbd> 
 enlarge vectors.</p>

You can extract subarrays using index
notation, as in <kbd>parta=a[100:156,200:296]</kbd>.</p>

</ul>

<li>The <b>maximum value of an IDL floating point constant</b> is about
3e38.  To deal with larger numbers, you must use <b>double-precision</b>.
E.g. in computations involving the speed of light, good practice is to
define <kbd>c = 3.0d10</kbd> rather than <kbd>c = 3.0e10</kbd>.  The largest
double-precision constant allowed is about 4d88.  (Minimum values are
the inverses of these.)  Computations which produce out-of-range
values will lead to "overflow" or "underflow" error messages.  </p>

<li>Beware of <b>implicit definition of variables</b>.</p>

<ul>
IDL <u>dynamically defines</u> variable type, and this is a classic
source of IDL novice errors.</p>

For instance, <kbd>x=5/2</kbd> returns the value 2 (integer) while
<kbd>x=5.0/2</kbd> returns 2.5 (floating point).  <kbd>x</kbd> has
different values and attributes in consequence.  Watch out!  For
insurance, a good habit is always to enter numbers in floating point
calculations with decimal points.  E.g. <kbd> diam = 2.*radius </kbd>. </p>

The result of a computation involving mixed types is influenced
by the order in which IDL evaluates an expression:

<ul>
<pre>
<kbd>
          IDL>print,6.*500.*70.*70.
              1.47000e+07

          IDL>print,6*500*70*70
              19936

          IDL>print,6*500*70*70.
              937440.

          IDL>print,6*500*70.*70
              1.47000e+07
</kbd>
</pre>
</ul>

</ul>

<li> <b>Implicit redefinition of array variables</b> can lead to big difficulties
as in the following:</p>
<pre><kbd>
       A=fltarr(200,200)    ; Define floating point array with all elements
                            ;     = 0.0
       A(*,*)=1. </kbd>OR<kbd> A=A+1.  ; Proper way to fill array A with 1.0

       A=1.0                ; Wrong way to fill array A with 1.0.  
                            ; You have just changed A to the scalar 1.0!
</kbd> </pre>

<li>Another potential problem area lies in <b>extracting vectors from
arrays.</b> In IDL a 1-D vector is assumed to be a <em>ROW</em>
vector. </p> 

<ul>

Thus, if <kbd>a</kbd> is a 100x100 array, <kbd>b=a[*,40]</kbd> will
create a row-vector of dimension (100).  But <kbd>b=a[40,*]</kbd> will
create a <em>2-D ARRAY</em> with dimension (1,100) (= a column
vector). </p>

To eliminate the orphan dimension here and obtain a standard row
vector, use the <kbd>reform</kbd> function:  <kbd>b=reform(b)</kbd>.
You could also use the <kbd>transpose</kbd> function to convert
the column vector into a row vector.</p>

You can check the current structure
for a variable using the <kbd>help</kbd> command. </p>

<!-- This isn't true in the case just discussed.  Evidently, if the
leading dimension is 1, the values are printed horizontally. 
Also, the
<kbd>print</kbd> command prints row vectors across the screen and
column vectors down the screen.  </p>   -->
 
</ul>


<li>Here is an example of another problem you can encounter with IDL's
<b>implicit definition of variable type</b> involving a dependent
variable array from which you want to extract a particular value.  If
<kbd>time</kbd> is the independent variable and <kbd>value</kbd> is
the dependent variable, you might want to locate a particular entry in
<kbd>value</kbd> as follows and renormalize the value array: </p>

<pre> <kbd>
           find=where(time eq 1000.)
           norm0=value(find)
           normalval=value/norm0  </kbd></pre>

<ul>

<p>Naively, you expect <kbd>norm0</kbd> to be a scalar, as it would be
if you typed <kbd>norm0=value(151)</kbd>, for instance.  However, if
you try this, you will find that here it is not a scalar, but instead
has type <em>array(1)</em>.  This is because the <kbd>where</kbd>
routine returns a <em>vector</em>, which definition propagates through to the
definition of <kbd>norm0</kbd>.  The resulting quantity,
<kbd>normalval</kbd>, which divides two vectors of different lengths,
is therefore a scalar, not a vector!  The <kbd>reform</kbd> function
is no help here.  To get the intended result, you must define
the normalizing constant as:  <kbd>norm0=value(find[0])</kbd>. </p>

<!-- you could also convert
<kbd>norm0</kbd> to a scalar using an array function with a scalar
output: e.g.  <kbd>norm0=total(value(find))</kbd> or <kbd>norm0=
max(value(find))</kbd>. 
-->

<p>If you are writing code for general application, you would also
want to confirm that <kbd>find</kbd> returns only a single
non-negative element.  The number of elements returned by the
<kbd>where</kbd> function can be determined, for instance, as follows:</p>
<pre> <kbd>
           find=where(time eq 1000.,count) 
           if (count eq 1 ) then begin... </kbd>  </pre> 
	
</ul>


<li>When working with arrays (e.g. CCD images) where the data
has limited dynamic range and does not require more than 2-byte
precision, it may be faster and more convenient to <b>convert them to
integer form</b> after multiplying by a scale factor than to leave them in
floating-point form.  This saves storage, increases execution speed,
and often reduces typing.  You can save manipulated versions by
back-converting, but you have to be careful to check that you haven't
lost any bits off the end. </p>

<li>Procedures that require <b>vector arguments</b> include
<kbd>max</kbd> and <kbd>min</kbd>.  If <kbd>a,b,c,d</kbd> are scalars,
you must enter <kbd>print,max([a,b,c,d])</kbd> rather than
<kbd>print,max(a,b,c,d)</kbd>.</p>

<ul>

Miswriting statements like <kbd>x = max(a,b)</kbd> can actually result in a
<em>changed value for b</em>.  Beware.  </p>

</ul>

<li>Functions such as <kbd>smooth, rebin,</kbd> and other resampling routines
usually preserve the variable type.  When applied to <b>integer arrays, 
numerical errors can be introduced by truncation</b>.  If you
are interested in preserving data values with such routines, you
should apply them only to floating point arrays.  To convert
an integer array to floating point, enter <kbd>a = float(a)</kbd>. </p>

<li>Remember that the <b>main level of IDL will not recognize variables
which are defined in procedures</b> (subroutines) but are not passed
through calling parameters back to the main program.  (Same as in
FORTRAN.)  Internal variables vanish on a normal exit from a
procedure.  To determine which variables are active, use
<kbd>help</kbd>.  You can, however, use <em>common blocks</em> (as in
FORTRAN) to establish links between main level and subroutine level
variables which are not in the calling sequence.  Main programs have
access to all variables which have been defined at the "main"
level.</p>

<li>  You can also
<em>define your own system variables</em>, which are known to all
programs, using <kbd>defsysv</kbd>.   </p>

<li>IDL <b>structures</b> provide a compact and convenient way of
moving large numbers of related variables of various types (scalars,
arrays, strings) between procedures and main programs.</p>


</ul>

<u><b>Differences from FORTRAN & C</b></u></p>

<ul>

<li>A frequent source of minor trouble for users of other high level
languages are the <b>small differences in IDL syntax for if
statements, then statements, do loops,</b>etc.  The latter in IDL are
<b>for loops</b>.  Also note the use of the <kbd>case</kbd> and
<kbd>goto</kbd> statements.  It is worth spending some time reviewing
these areas before writing IDL code.  </p>

<!-- 
 <kbd>if,
then, for, do,</kbd> etc., statements and in logical expressions.
-->

<li>IDL's <b>element subscripting convention for 2-D arrays is reversed
from FORTRAN.</b> In FORTRAN, <kbd>A[i,j[</kbd> corresponds to the
element in the <em>ith ROW and jth COLUMN.</em>  But in IDL,
<kbd>A[i,j]</kbd> corresponds to the element in the <em>ith COLUMN and
jth ROW.</em>  <kbd>A[*,j]</kbd> is a <em>row vector</em>. 
<kbd>A[i,*]</kbd> is a <em>column vector.</em> </p>

<ul>

 This convention was adopted for IDL because it produces the standard
sense for <kbd>(x,y)</kbd> displays.  The default display commands
will show an array <kbd>A(x,y)</kbd> starting with column 0 at the
left of the screen and row 0 at the bottom.  When displayed,
<kbd>A(4,1)</kbd> will be four units to the right and one unit up from
the origin.  This change in convention obviously requires care if one
is trying to operate on a given dataset with both IDL and FORTRAN.
</p>

</ul>

</ul>

<u><b>Punctuation, Syntax, etc</b></u></p>

<ul>

<li> For a quick reminder of IDL syntax,
see <a href="idl-syntx-sterner.html">Ray
Sterner's IDL Statement Syntax page</a>.</p>

<li>  <b>IDL is not case-sensitive,</b> though LINUX is.  Commands which will
involve the operating system (e.g. reading/writing files) therefore
must observe case conventions.  </p>

<li> The <b>period in executive commands</b> (e.g. <kbd>
.run</kbd>) must appear as the
<b>first</b> character of the command line (no preceding blanks). </p>

<li>  The <b>"single-quote"</b> mark for strings, filenames, etc., is the
apostrophe ('), not the "leading-single-quote-mark" (`).  Syntax
errors occur if you switch these.  Unfortunately, on many terminal
screens, these are hard to distinguish.  On some keyboards,
they are also on adjacent keys, which promotes typing errors. </p>

<li>  <b>Strings must always appear in quotes;</b> file names are treated as
strings in most routines involving files.</p>

<ul>

If a string is the last
entry on a line (no further parameters or punctuation), then the
trailing quote mark need not be entered.  But in this case, be sure
you <b>don't enter an extra blank space</b> on the terminal before
pressing "return", or the string may be incorrectly read.   </p>

</ul>

<li> A common typo which can lead to a syntax error is the
<b>substitution of a period for a comma</b> in a procedure argument list. </p>

<li>  Recall that a <b>vector is identified by enclosing brackets, not
parentheses: </b> <kbd>x=[47,29,135]</kbd>, not <kbd>x=(47,29,135)</kbd>.</p>

<li> Beware of inadvertently typing mathematical operators where you should
use <b>relational operators</b>.  E.g.:   <kbd>if (x = 5) then ...</kbd> instead of
the correct <kbd>if (x eq 5) then ...</kbd>.  This can produce serious bugs
that don't necessarily raise error flags.</p>

<li>  Recall that the <kbd>></kbd> and
<kbd><</kbd> signs invoke the "maximum" and "minimum" operators, respectively.
E.g. <kbd>10 > 15</kbd> is the scalar <kbd>15</kbd>. </p>

</ul>


<u><b>Other Issues</b></u></p>

<ul>

<li>It is a good idea to make liberal use of the <kbd>sxaddhist</kbd>
routine to <b>update the comments on your data set</b> as you read,
process, and save FITS images.  </p>

<li>Since interactive IDL sessions often produce a large number of
active variables, it is useful to <b>be systematic in naming each new
variable.</b> E.g. in reading arrays, use conventions like:
<kbd>fits_read,'filename',pic1,hdpic1</kbd> to keep the
image and header arrays straight.  </p>

<li>To save typing and looking up long file paths, it's useful to
<b>define special string variables </b>which contain the fully
qualified names of your frequently used directories.  Then you can
just <kbd>sd,[stringname]</kbd> to change directories.  </p>

<li>If you <b>manipulate the color tables</b>, you will probably want
to reload a standard table (e.g. <kbd>loadct,0</kbd>) before
displaying a new image.</p>

</ul>


<u><b>Programming Philosophy</b></u></p>

<ul> 

<li> Some IDL users like to write a <b>specific, single-purpose main
program</b> to perform a particular task and then change it, or
proliferate multiple versions, to deal with similar but slightly
different applications (e.g. a new data set).  However, since main
program input/output is not made explicit when you <kbd>.run</kbd> a
main program, the <kbd>journal</kbd> file does not succinctly capture it.
Furthermore, unless one deliberately renames and saves the main program
every time it is changed, it may not be possible to reconstruct what actually
happened.  
 </p>

<li> Other users prefer to write
<b>more generalized subroutines</b>, which take defined
sets of input parameters but which can perform the function on a
variety of different inputs.  They then <kbd>journal</kbd> the sessions in which
the routine is actually applied.  In this method, the specific input to
and output from each subroutine are clearly and concisely documented. 
<p>


<li><b>The latter approach produces software which is usually more
reliable and stable over long periods</b> (not to mention usable
by others), and it is easier to reconstruct what was done at a
particular time.  Other advantages, which can be crucial, are that in
writing a more generalized subroutine, you are more likely to spend
the time to review the logic, to adequately document what the routine
does, and to catch typing errors (which can sink you in the main
program approach).  I have found this to be much more reliable than
the "single-shot" main program approach.</p>

<li> Whichever method you use, <b>you should</b> <kbd>journal</kbd>
<b>everything if you are doing serious work.</b> <p>

<li>Although it is possible to concatenate many IDL procedures into a
single <em>*.pro</em> file and to compile them all with one command,
this prevents you from using the <kbd>man</kbd> help procedure, which
lists headers based on assumed file names.  It will also prevent
<kbd>file_which</kbd> from locating embedded programs.  Unless you are
dealing with large packages with numerous subroutines that are better
kept together, it's cleaner and less confusing in the long run to
<b>keep all procedures in separate files.</b> You can always write
batch compilation files which catch all procedures needed for a given
task.  Or you can simply let the automatic compilation system find and
compile programs when they are first referenced.  This is less trouble
and just as fast.  <p>

</ul>

<p><br></p>

<hr size=3>

<h1 align=center> III. APPENDICES </h1>

<hr>

<h2 align=center><a name="setup">  APPENDIX A:  IDL SETUP </a> </h2>

<p><a href="#contents"> [Up to Contents]</a></p>

<p>Before executing IDL, you must define a special set of IDL environment
variables, so that LINUX and IDL know where to look for the various
IDL executable and program packages.  Normally, you do this by
<kbd>source</kbd>-ing a special <b><em>idl_env</em> file</b>.  Default
environment files are contained in each IDL distribution from Exelis.  

<ul>

<p><b> To use the UVa Astronomy Department system defaults, 
give the command: <kbd>source /astro/idl/idl_env.csh</kbd>.  (For a
Bash session, use <kbd>idl_env.sh</kbd>.)  You will be automatically
set up to use the latest version of IDL including the MOUSSE package
as installed on our local servers. If you are happy with the system
defaults, you can ignore the rest of this section,</b> except for
morbid curiosity.</p>

</ul>

On the other hand, if you want to customize your
IDL configuration, you need to know the details of the various
environment variables.  <p>

<ul>

You cannot change the contents of the <em>idl_env</em> file or the
defined environment variables after IDL begins execution.</p>

Instead of using <em>idl_env</em>, you could define the
various required IDL environment variables in your <em>.login</em>
or <em>.cshrc</em> files.  However, it is cleaner to keep all such
definitions together in a separate
<em>idl_env</em> file.  </p>

As an example environment setup file, the standard UVa file is shown
under <a href="#envex">Appendix B</a> below.

<!-- The file that configures a default session on the UVa
Astronomy Department network is named <kbd>/astro/idl/idl_env.csh</kbd>.
(For a BASH session, use <kbd>idl_env.sh</kbd>.)</p>  -->

</ul>

The first item that must be defined is 
 <kbd>$IDL_DIR</kbd>, the <b>location of the main IDL directory</b>.
Intrinsic IDL executables are kept there.  Which <kbd>$IDL_DIR</kbd>
you define determines which version of IDL you will execute. </p>

<ul>

Each set of executables is authorized by Exelis to run on only certain
hosts, so you must point <kbd>$IDL_DIR</kbd> to the appropriate
directory for your current host to run IDL other than in a 7 minute,
stripped-down, "demo" mode.  The executables must be compatible with
the current version of the operating system running on your host.  </p>

</ul>

You must also specify the location of the <b>IDL license file</b>
that authorizes your host to execute IDL.  Licenses are issued for
single or multiple hosts.  The UVA license supports 50 hosts simultaneously.
The environment variable pointing to the license file is named
<kbd>$LM_LICENSE_FILE</kbd>.</p>

<p>You must also specify the <b> <u>search path</u> for all <em>*.pro</em>
routines you wish to use</b> (other than the intrinsic Exelis routines).</p>

<ul>


The path is defined in the LINUX shell
variable <kbd>$IDL_PATH</kbd>, which is converted to the IDL system
variable <kbd>!path</kbd>.</p>

Once <kbd>$IDL_PATH</kbd> has been defined, it <b>cannot be changed
during an IDL session</b>.</p>

IDL's default in the absence of a specified path is to use the
<b>current directory only</b>.</p>

When IDL looks for a named routine, the path is searched in order from
the first entry to the last.  The first file with the expected name
is executed.</p>

The search path should include the IDL
User's Library (distributed with native IDL), the IDL Astronomical
User's Library, the ATV directory, and the MOUSSE directory.</p>

The path should also include your
own <kbd>idl</kbd> directory and any other directories containing
customized routines which you wish to invoke without making them the
current directory.  </p>

<b><u>Beware of multiple versions</u> of the same program</b> (e.g. an AstUseLib
version and a Users Library version)!  You must arrange your path
so that <b>the preferred version occurs <u>first</u> in the path.</b></p>

At UVa, the AstUseLib versions are preferred, and should be placed
first in your path except for your own <kbd>idl</kbd> directory.</p>

Recommended path structure (see examples below for syntax):</p>

<ul>

<pre><b>
  [current directory], [your idl directory], [other special local
  *.pro libraries, if any], [Astronomy Users Library], [MOUSSE], 
  [ATV], [IDL Users Library]. </b> </pre>

</ul></ul>

<p>Separately, if you wish to use the databasing software, <b>you must
specify the location of the IDL databases</b> (the <em>zdbase</em>
directory).</b>.</p>

In order <b>to customize your IDL session</b> further, you can define
the <kbd>$IDL_STARTUP</kbd> environment variable.  The file to which
this variable points will be executed at the beginning of your IDL
session.  This startup file can execute an arbitrary number of other
IDL programs and scripts.  The default at UVa is to execute the startup
file <kbd>mousse_startup.pro</kbd>. 
Among other items, this executes the
procedure <kbd>cinit.pro</kbd>; <b>many MOUSSE
routines will fail if <kbd>cinit</kbd> is not executed.</b></p>

 </p>

Finally, the <em>idl_env</em> file also establishes <b>aliases for 
the various IDL executable files</b>.</p>

<p>When you give the command <kbd>idl</kbd> under the following setup, this is
what happens:

<ol>
<li> The executable <em>idl</em> located in <kbd>$IDL_DIR</kbd> is retrieved</p>

<li> The Exelis/IDL license is checked </p>

<li> If your host computer is authorized to use IDL, the normal
program is executed</p>

<li> If you are not licensed for IDL, the program runs in a 7-minute
"Demo" mode</p>
               
<li> The shell variables starting with <em>IDL</em> are converted
                 to corresponding internal IDL system variables</p>

<li> The file <kbd>$IDL_STARTUP</kbd> is executed, if defined.</p>


<!-- 
<ul>
At UVa, the default startup file enables your session to use the
MOUSSE software, including special common blocks and display
procedures.  You can use this default version
(<kbd>mousse_startup.pro</kbd>), or you can specify a personalized
version which includes all the statements in the default plus other
customizing statements.  The startup file executes the MOUSSE
procedure <kbd>cinit.pro</kbd>; <b>many MOUSSE
routines will fail if <kbd>cinit</kbd> is not executed.</b></p>
</ul>
-->

</ol>

<p><br></p>

<hr>

<h2 align=center> <a name="envex"> APPENDIX B: ENVIRONMENT SETUP EXAMPLE </a></h2>

<p><a href="#contents"> [Up to Contents]</a></p>


<!--  July 09: changed from the Solaris8 to the LINUX version of
the local environment file (/astro/idl/idl_env.csh)   -->

<pre>

<b>
### This is the UVa Astronomy LINUX system default env file 
### as installed on the department server, March 2009.
### Location is:  /astro/idl/idl_env.csh
</b>

# C shell commands to define IDL environment variables and aliases.
#
# Script name: idl_env.csh
#
# This script is used by C shell users to define 
# the environment variables and aliases required by IDL
# related commands.
#
# To execute this script, give the following command; or,
# for automatic execution, place it in your .cshrc file.
#
#    source /astro/idl/idl_env.csh
#
# To overwrite the defaults set in this file, you can source other
# setup files from your individual .cshrc file.
#

##### 
# System choice - deprecated 03-07-11
#####
# set sys=`uname -a | awk '{print $3}'`
# if ( $sys == 5.6 ) then
#          setenv IDL_DIR          /net/astsun.astrosw/idl/
#       else
#          setenv IDL_DIR          /net/jeeves.common/rsi/idl/
# endif

# Note: the March 2009 configuration substitutes a departmental version
#       of IDL v7.0 (/astro/itt/idl) for the UVa v6.4 version
#       (/common/rsi/idl). 

#setenv IDL_DIR          /common/rsi/idl/
setenv IDL_DIR          /astro/itt/idl/
setenv IDL_HOME         ${IDL_DIR}
#setenv IDL_HELP                /common/rsi/idl/help
setenv IDL_HELP         /astro/itt/idl/help

# License file

#setenv LM_LICENSE_FILE /common/rsi/license/license.dat
setenv LM_LICENSE_FILE /astro/itt/license/license.dat

# Local packages

setenv ASTROLIB_DIR     /astro/idl/Astrolib
setenv MOUSSE_DIR       /astro/idl/Mousse
setenv MOUSSE98_DIR     /astro/idl/Mousse.98
setenv PIA_LOC_GEN      /astro/idl/PIA/
setenv ATV_DIR          /astro/idl/atv
setenv FUSE_DIR         /astro/idl/FUSE

setenv IDL_HELP_PATH    "+${MOUSSE_DIR}:+${ASTROLIB_DIR}:+${IDL_HELP}"

# ZDBASE is the location of the IDL-formatted databases 

setenv ZDBASE           /astro/idl/zdbase

# Notes on IDL_PATH
# 
# Symbol "+" means that the path will be expanded to include all
#   subdirectories within the given directory.  
# The user's own IDL programs are assumed to be in a directory named,
#   or linked to, "idl" under the user's home directory
# Directory $IDL_HOME/lib contains the IDL User's Library of
#   standard user-written utility routines.  

setenv IDL_PATH         ".:+~/idl:/astro/idl/UVAlocal:+${ASTROLIB_DIR}:${ATV_DIR}:+${MO
USSE_DIR}:+${MOUSSE98_DIR}:+${IDL_HOME}/lib:+${IDL_HOME}/examples:+${PIA_LOC_GEN}:+${FU
SE_DIR}"

setenv UIT_DATA         ${IDL_HOME}/data

setenv IDLUSR           ${HOME}
setenv IDLUSER          ${HOME}

alias idl $IDL_DIR/bin/idl
alias idlde $IDL_DIR/bin/idlde
alias idldeclient $IDL_DIR/bin/idldeclient
alias idlhelp $IDL_DIR/bin/idlhelp
alias idlrpc $IDL_DIR/bin/idlrpc
alias insight $IDL_DIR/bin/insight
alias idldemo $IDL_DIR/bin/idldemo

alias pia $PIA_LOC_GEN/PIA

# The following IDL startup file will be executed before
#    each IDL session.  User can specify a different
#    startup in his/her .cshrc file.

setenv IDL_STARTUP /astro/idl/startup/mousse_startup.pro

</pre>

<hr>

<h2 align=center><a name="startex"> APPENDIX C:  MOUSSE STARTUP FILE EXAMPLE </a></h2>

<p><a href="#contents"> [Up to Contents]</a></p>

<b>"Startup" files</b> are batch files which are automatically executed
when IDL begins running.  They enable to user to customize
his/her IDL session.  </p>

The startup file is often placed in <kbd>$IDL_DIR</kbd>.  However, it can be
anywhere.  In order for IDL to locate it, you must point the
environment variable <kbd>$IDL_STARTUP</kbd> to it.  If this variable is not
defined, no startup file will be executed.</p>

This particular example defines special "systems variables" and
common blocks used by the MOUSSE image processing package.  These
improve the efficiency of the package and reduce the number of typed
entries the user must make to use it.  </p>

<b>Contents of mousse_startup.pro: </b></p>

<pre>

  ; STARTUP FILE mousse_startup.pro
  ; Last Modified: 15 May 1992, 30 Sep 93, 27 Dec 93, 22 Aug 97

print , "Running mousse_startup.pro..."
print , "For help on AstUseLib and Mousse routines, use the Mousse MAN procedure."

setplot, 'X'
DEFSYSV,'!DEBUG',0
DEFSYSV,'!TEXTUNIT',0
DEFSYSV,'!TEXTOUT',1
DEFSYSV,'!PRIV',0
defsysv,'!psprinter','astro-hp'     ;  UVA default printer
cinit              ; CINIT sets up MOUSSE common blocks 
!PROMPT = 'IDL>'
!EDIT_INPUT = 100
on_error,1         ; Return to main program in case of error
print,' *** on_error,1 is default ***'
print,' *** If terminal is vt100/tek, type SETPLOT,0'

</pre>

<hr>

<h2 align=center><a name="windows">APPENDIX D:   X-WINDOWS NOTES </a></h2>

<p><a href="#contents"> [Up to Contents]</a></p>

<p>This guide assumes you are executing IDL from within an X-WINDOWS 
 environment.  So:  first, you must start your windows
system and open an appropriate window to enter IDL commands.  The
location of display windows opened by various IDL applications can be
controlled in many instances.  Consult the description of
<kbd>xpos</kbd> under the <kbd>window</kbd> command.  It is useful to
place display windows away from your command window, wherever
possible.  You can move existing windows using your mouse.  </p>

On an Apple MAC, you must ordinarily manually start the <kbd>X11</kbd>
program.  You can select a monitor display class from its <kbd>Preferences</kbd>
menu; changes here will not take effect until after you exit and
re-start <kbd>X11</kbd>.  You must execute IDL from within an
X-window in order to use graphics.</p>

<p>Normally, you run IDL on your local machine with display on your
local terminal.  To run IDL on a remote host which supports X-windows
with display on your local terminal, do the following:

<ol>

<li>  Edit the <em>.xinitrc</em> file on your local machine to
         include the statement <kbd>xhost [remote host]</kbd>, where
         <kbd>[remote host]</kbd> = the fully qualified network name of
         the IDL host you wish to use.  E.g.: </p>

<center>  <kbd> xhost parfait.gsfc.nasa.gov </kbd>  </center></p>

<li>  Start X-windows on your local machine.</p>

<li>  <kbd>ssh</kbd> or <kbd>telnet</kbd> to the remote IDL host and login</p>

<li>  To obtain X-windows output from the IDL host on your
         local machine, type</p>

    <center>  <kbd>setenv DISPLAY [local]:0.0 </kbd> </center></p>

<p> where <kbd>[local]</kbd> is the fully qualified network name
         of your local machine, e.g.</p>

    <center><kbd>  setenv DISPLAY bonkers.astro.virginia.edu:0.0 </kbd></center></p>

<li>  Start IDL on the remote machine </p>

<li> New windows created by IDL should now appear on your local
terminal.  Of course, data display in this mode will be
slower than if you were running on the local machine.
</p>  

</ol>

						   
<!-- START FOOTER -->

<hr size=5>

<center>
  <p><a href="#contents"> [To top of IDL GUIDE ]</a></p>
</center>

<hr size=5 >

<center><small>
  <p> This Guide is copyright &copy 1991-2015 by Robert W. O'Connell.  All
rights reserved.<br>  Reproduction or distribution without attribution
and commercial uses are prohibited. </center></small>

<hr>

<center> <p> <small><i>Contents last modified
   <b>June 2012</b> by RWO.  Email:  rwo [at] virginia [dot] edu </i>
         </small></center></p>

      <!-- END FOOTER -->

 </font>

 </div>
 </body>
 </html>
       

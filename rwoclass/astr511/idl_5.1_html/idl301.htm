<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML EXPERIMENTAL 970324//EN">
<HTML>
<STYLE><!--
H1         { font-family: Stone Sans, Helvetica, Arial, sans-serif }
H1.Chapter-Name    { font-size: 36pt }
H2         { font-family: Stone Sans, Helvetica, Arial, sans-serif }
H3         { font-family: Stone Sans, Helvetica, Arial, sans-serif }
H4         { font-family: Stone Sans, Helvetica, Arial, sans-serif }
H5         { font-family: Stone Sans, Helvetica, Arial, sans-serif ;
             margin-top: -5.0pt ; font-size: 12pt }
H6         { font-family: Stone Sans, Helvetica, Arial, sans-serif ;
             margin-top: -5.0pt ; font-size: 12pt }
P          { font-family: Minion, Times, serif }
P.api      { font-family: Courier ; font-weight: Bold }
P.Code     { font-family: Courier, serif ; font-size: 10pt}
P.Code-2   { font-family: Courier, serif ; font-size: 10pt}
P.Code-Result   { font-family: Courier, serif ; font-size: 10pt ;
                  font-weight: Bold}
P.ChapTOC  { font-family: Stone Sans, Helvetica, Arial, sans-serif }
P.Chapter-NameTOC   { font-family: Stone Sans, Helvetica, Arial, sans-serif ;
		      font-size: 20pt; font-weight: Bold }
P.Level2IX	{margin-left: 10pt }
LI.Code-Numbered     { font-family: Courier, serif ; font-size: 10pt}
LI.Code-Numbered-1   { font-family: Courier, serif ; font-size: 10pt}
--></STYLE>

<HEAD>
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">

<TITLE> IDLgrPolygon</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<DIV><table width="100%" border=0 cellspacing=0 cellpadding=0> <TR>  <TD></TD>   <TD  bgcolor="#ffffff">     <IMG SRC = "idlmap.gif" USEMAP = "#idlmap.gif" BORDER = 0>   </TD> </TR></TABLE><MAP NAME = "idlmap.gif"><AREA SHAPE=RECT HREF="idl302.htm" COORDS="290, 29, 344, 43"><AREA SHAPE=RECT HREF="idl.htm" COORDS="139, 29, 239, 46"><AREA SHAPE=RECT HREF="idl300.htm" COORDS="0, 29, 98, 46"><AREA SHAPE=RECT HREF="idl.htm" COORDS="68, 0, 275, 18"></MAP></DIV><HR></DIV>
<H1 CLASS="Class-Name">
<A NAME="pgfId=997835">
 </A>
<A NAME="46829">
 </A>
IDLgrPolygon</H1>
<P CLASS="Body">
<A NAME="pgfId=997836">
 </A>
A <A NAME="marker=1022382">
 </A>
polygon object represents one or more polygons that share a given set of vertices and rendering attributes. All polygons must be convex--that is, a line connecting any pair of vertices on the polygon cannot fall outside the polygon. Concave polygons can be converted to a set of convex polygons using the <A HREF="idl307.htm#27071" CLASS="XRef">
IDLgrTessellator</A>
 object.</P>
<P CLASS="Body">
<A NAME="pgfId=1040102">
 </A>
An IDLgrPolygon object is an<EM CLASS="Emphasis">
 atomic graphic object</EM>
; it is one of the basic drawable elements of the IDL Object Graphics system, and it is not a container for other objects.</P>
<DIV>
<H3 CLASS="Heading-2R">
<A NAME="pgfId=1038549">
 </A>
Superclasses</H3>
<P CLASS="Body">
<A NAME="pgfId=1038550">
 </A>
This class has no superclasses.</P>
</DIV>
<DIV>
<H3 CLASS="Heading-2R">
<A NAME="pgfId=1005877">
 </A>
Subclasses</H3>
<P CLASS="Body">
<A NAME="pgfId=1005878">
 </A>
This class has no subclasses.</P>
</DIV>
<DIV>
<H2 CLASS="Heading-1R">
<A NAME="pgfId=1005879">
 </A>
Creation</H2>
<P CLASS="Body">
<A NAME="pgfId=1005880">
 </A>
See <A HREF="idl2f5.htm#17584" CLASS="XRef">
IDLgrPolygon::Init</A>
</DIV>
<DIV>
<H2 CLASS="Heading-1R">
<A NAME="pgfId=1005892">
 </A>
Methods</H2>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1005893">
 </A>
Intrinsic Methods</H3>
<P CLASS="Body">
<A NAME="pgfId=1005894">
 </A>
This class has the following methods:</P>
<UL>
<LI CLASS="Body-Bullet-2">
<A NAME="pgfId=1005902">
 </A>
<A HREF="idl301.htm#42541" CLASS="XRef">
IDLgrPolygon::Cleanup</A>
<LI CLASS="Body-Bullet-2">
<A NAME="pgfId=1038817">
 </A>
<A HREF="idl301.htm#10798" CLASS="XRef">
IDLgrPolygon::GetCTM</A>
<LI CLASS="Body-Bullet-2">
<A NAME="pgfId=1033815">
 </A>
<A HREF="idl301.htm#56846" CLASS="XRef">
IDLgrPolygon::GetProperty</A>
<LI CLASS="Body-Bullet-2">
<A NAME="pgfId=1013218">
 </A>
<A HREF="idl2f5.htm#17584" CLASS="XRef">
IDLgrPolygon::Init</A>
<LI CLASS="Body-Bullet-2">
<A NAME="pgfId=1005906">
 </A>
<A HREF="idl301.htm#84664" CLASS="XRef">
IDLgrPolygon::SetProperty</A>
</UL>
<P CLASS="Body">
<A NAME="pgfId=1173689">
 </A>
&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId=1173690">
 </A>
&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId=1173691">
 </A>
&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId=1173692">
 </A>
&nbsp;</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Method-Name">
<HR><A HREF="#top"><IMG SRC="buttonup.gif" ALIGN="right" BORDER=0></A>
<A NAME="pgfId=1033801">
 </A>
<A NAME="42541">
 </A>
IDLgrPolygon::Cleanup</H2>
<P CLASS="Body">
<A NAME="pgfId=1033804">
 </A>
The IDLgrPolygon::<A NAME="marker=1052274">
 </A>
Cleanup procedure method performs all cleanup on the object. <STRONG CLASS="Stone-Semibold">
<A HREF="idl301.htm#46829" CLASS="XRef">
IDLgrPolygon</A>
 </STRONG>
is described above.</P>


<UL>
<P CLASS="Note"><b><FONT SIZE=+1>NOTE: </FONT></b>
<A NAME="pgfId=1041826">
 </A>
Cleanup methods are special <EM CLASS="Emphasis">
lifecycle methods</EM>
, and as such cannot be called outside the context of object destruction. This means that in most cases, you cannot call the Cleanup method directly. There is one exception to this rule: If you write your own subclass of this class, you can call the Cleanup method from within the Cleanup method of the subclass.</LI>
</UL>
</DIV>
<DIV>
<H2 CLASS="Heading-1R">
<A NAME="pgfId=1031418">
 </A>
Calling Sequence</H2>
<P CLASS="Body">
<A NAME="pgfId=1051197">
 </A>
OBJ_DESTROY, <EM CLASS="Emphasis">
Obj</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId=1051198">
 </A>
<EM CLASS="Emphasis">
or</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId=1031419">
 </A>
<EM CLASS="Emphasis">
Obj </EM>
<CODE CLASS="Code">
-&gt;</CODE>
<EM CLASS="Emphasis">
[IDLgrPolygon::]</EM>
Cleanup&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<EM CLASS="Emphasis">
In a subclass' Cleanup method only</EM>
.)</P>
</DIV>
<DIV>
<H2 CLASS="Heading-1R">
<A NAME="pgfId=1031420">
 </A>
Arguments</H2>
<P CLASS="Body">
<A NAME="pgfId=1031421">
 </A>
There are no arguments for this method.</P>
</DIV>
<DIV>
<H2 CLASS="Heading-1R">
<A NAME="pgfId=1031422">
 </A>
Keywords</H2>
<P CLASS="Body">
<A NAME="pgfId=1031423">
 </A>
There are no keywords for this method.</P>
</DIV>
<DIV>
<H2 CLASS="Method-Name">
<HR><A HREF="#top"><IMG SRC="buttonup.gif" ALIGN="right" BORDER=0></A>
<A NAME="pgfId=1038791">
 </A>
<A NAME="10798">
 </A>
IDLgrPolygon::GetCTM</H2>
<P CLASS="Body">
<A NAME="pgfId=1038794">
 </A>
The IDLgrPolygon::<A NAME="marker=1052277">
 </A>
GetCTM function method returns the 4 x 4 graphics transform matrix from the current object upward through the graphics tree. <STRONG CLASS="Stone-Semibold">
<A HREF="idl301.htm#46829" CLASS="XRef">
IDLgrPolygon</A>
 </STRONG>
is described above.</P>


</DIV>
<DIV>
<H2 CLASS="Heading-1R">
<A NAME="pgfId=1038798">
 </A>
Calling Sequence</H2>
<P CLASS="Body">
<A NAME="pgfId=1038799">
 </A>
Result = <EM CLASS="Emphasis">
Obj</EM>
 <CODE CLASS="Code">
-&gt;</CODE>
<EM CLASS="Emphasis">
[IDLgrPolygon::]</EM>
GetCTM()</P>
</DIV>
<DIV>
<H2 CLASS="Heading-1R">
<A NAME="pgfId=1038800">
 </A>
Arguments</H2>
<P CLASS="Body">
<A NAME="pgfId=1038801">
 </A>
There are no arguments for this method.</P>
</DIV>
<DIV>
<H2 CLASS="Heading-1R">
<A NAME="pgfId=1038802">
 </A>
Keywords</H2>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1038804">
 </A>
<A NAME="marker=1038803">
 </A>
DESTINATION</H3>
<P CLASS="Body">
<A NAME="pgfId=1058051">
 </A>
Set this keyword to the object reference of a destination object to specify that the projection matrix for the View object in the current tree be included in the returned transformation matrix. The resulting matrix will transform a point in the data space of the object on which the GetCTM method is called into a normalized coordinate system (-1 to +1 in X, Y, and Z), relative to the View object that contains the polygon object.</P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1047313">
 </A>
<A NAME="marker=1047312">
 </A>
TOP</H3>
<P CLASS="Body">
<A NAME="pgfId=1059523">
 </A>
Set this keyword equal to the object reference to an <A HREF="idl2fc.htm#83081" CLASS="XRef">
IDLgrModel</A>
 object to specify that the returned matrix accumulate from the object on which the GetCTM method is called up to and including the specified model object.</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Method-Name">
<HR><A HREF="#top"><IMG SRC="buttonup.gif" ALIGN="right" BORDER=0></A>
<A NAME="pgfId=997876">
 </A>
<A NAME="56846">
 </A>
IDLgrPolygon::GetProperty</H2>
<P CLASS="Body">
<A NAME="pgfId=1005993">
 </A>
The IDLgrPolygon::<A NAME="marker=1052280">
 </A>
GetProperty procedure method retrieves the value of the property or group of properties for the polygons. <STRONG CLASS="Stone-Semibold">
<A HREF="idl301.htm#46829" CLASS="XRef">
IDLgrPolygon</A>
 </STRONG>
is described above.</P>


</DIV>
<DIV>
<H2 CLASS="Heading-1R">
<A NAME="pgfId=1005994">
 </A>
Calling Sequence</H2>
<P CLASS="Body">
<A NAME="pgfId=1005995">
 </A>
<EM CLASS="Emphasis">
Obj</EM>
 <CODE CLASS="Code">
-&gt;</CODE>
<EM CLASS="Emphasis">
[IDLgrPolygon::]</EM>
GetProperty</P>
</DIV>
<DIV>
<H2 CLASS="Heading-1R">
<A NAME="pgfId=997877">
 </A>
Arguments</H2>
<P CLASS="Body">
<A NAME="pgfId=1006006">
 </A>
There are no arguments for this methods.</P>
</DIV>
<DIV>
<H2 CLASS="Heading-1R">
<A NAME="pgfId=997878">
 </A>
Keywords</H2>
<P CLASS="Body">
<A NAME="pgfId=1016672">
 </A>
Any keyword to <A HREF="idl2f5.htm#17584" CLASS="XRef">
IDLgrPolygon::Init</A>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=997880">
 </A>
<A NAME="marker=1022565">
 </A>
ALL</H3>
<P CLASS="Body">
<A NAME="pgfId=1093587">
 </A>
Set this keyword to a named variable that will contain an anonymous structure containing the values of all of the properties associated with the <I CLASS="Italic">
state</I>
 of this object. State information about the object includes things like color, range, tick direction, etc., but not image, vertex, or connectivity data, or user values.</P>
<UL>
<P CLASS="Note"><b><FONT SIZE=+1>NOTE: </FONT></b>
<A NAME="pgfId=1093588">
 </A>
The fields of this structure may change in subsequent releases of IDL.</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1048933">
 </A>
<A NAME="marker=1048932">
 </A>
PARENT</H3>
<P CLASS="Body">
<A NAME="pgfId=1068349">
 </A>
Set this keyword equal to a named variable that will contain an object reference to the object that contains this object.</P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1039086">
 </A>
<A NAME="marker=1039084">
 </A>
XRANGE</H3>
<P CLASS="Body">
<A NAME="pgfId=1068387">
 </A>
Set this keyword equal to a named variable that will contain a two-element vector of the form [<EM CLASS="Emphasis">
xmin</EM>
, <EM CLASS="Emphasis">
xmax</EM>
] that specifies the range of <EM CLASS="Emphasis">
x</EM>
 data coordinates covered by the graphic object.</P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1039090">
 </A>
<A NAME="marker=1039088">
 </A>
YRANGE</H3>
<P CLASS="Body">
<A NAME="pgfId=1068410">
 </A>
Set this keyword equal to a named variable that will contain a two-element vector of the form [<EM CLASS="Emphasis">
ymin</EM>
, <EM CLASS="Emphasis">
ymax</EM>
] that specifies the range of <EM CLASS="Emphasis">
y </EM>
data coordinates covered by the graphic object.</P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1039094">
 </A>
<A NAME="marker=1039092">
 </A>
ZRANGE</H3>
<P CLASS="Body">
<A NAME="pgfId=1068435">
 </A>
Set this keyword equal to a named variable that will contain a two-element vector of the form [<EM CLASS="Emphasis">
zmin</EM>
, <EM CLASS="Emphasis">
zmax</EM>
] that specifies the range of <EM CLASS="Emphasis">
z </EM>
data coordinates covered by the graphic object.</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Method-Name">
<HR><A HREF="#top"><IMG SRC="buttonup.gif" ALIGN="right" BORDER=0></A>
<A NAME="pgfId=1013223">
 </A>
<A NAME="17584">
 </A>
IDLgrPolygon::Init</H2>
<P CLASS="Body">
<A NAME="pgfId=1013224">
 </A>
The IDLgrPolygon::<A NAME="marker=1052284">
 </A>
Init function method initializes the polygons object. <STRONG CLASS="Stone-Semibold">
<A HREF="idl301.htm#46829" CLASS="XRef">
IDLgrPolygon</A>
 </STRONG>
is described above.</P>


<UL>
<P CLASS="Note"><b><FONT SIZE=+1>NOTE: </FONT></b>
<A NAME="pgfId=1041717">
 </A>
Init methods are special <EM CLASS="Emphasis">
lifecycle methods</EM>
, and as such cannot be called outside the context of object creation. This means that in most cases, you cannot call the Init method directly. There is one exception to this rule: If you write your own subclass of this class, you can call the Init method from within the Init method of the subclass.</LI>
</UL>
</DIV>
<DIV>
<H2 CLASS="Heading-1R">
<A NAME="pgfId=1013228">
 </A>
Calling Sequence</H2>
<P CLASS="Body">
<A NAME="pgfId=1019715">
 </A>
Obj = OBJ_NEW('IDLgrPolygon' <EM CLASS="Emphasis">
[, X [</EM>
, <EM CLASS="Emphasis">
Y[</EM>
, <EM CLASS="Emphasis">
Z]]]</EM>
)</P>
<P CLASS="Body">
<A NAME="pgfId=1041974">
 </A>
<EM CLASS="Emphasis">
or</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId=1041975">
 </A>
Result = <EM CLASS="Emphasis">
Obj</EM>
 <CODE CLASS="Code">
-&gt;</CODE>
 <EM CLASS="Emphasis">
[IDLgrPolygon::]</EM>
Init(<EM CLASS="Emphasis">
[X, [Y, [Z]]] </EM>
)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<EM CLASS="Emphasis">
In a subclass' Init method only</EM>
.)</P>
</DIV>
<DIV>
<H2 CLASS="Heading-1R">
<A NAME="pgfId=1013230">
 </A>
Arguments</H2>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1013231">
 </A>
X</H3>
<P CLASS="Body">
<A NAME="pgfId=1013232">
 </A>
A vector argument providing the <EM CLASS="Emphasis">
X</EM>
 coordinates of the vertices. The vector must contain at least three elements. If the <EM CLASS="Emphasis">
Y</EM>
 and <EM CLASS="Emphasis">
Z</EM>
 arguments are not provided, <EM CLASS="Emphasis">
X</EM>
 must be an array of either two or three vectors (i.e., [2,*] or [3,*]), in which case, <EM CLASS="Emphasis">
X</EM>
[0,*] specifies the <EM CLASS="Emphasis">
X</EM>
 values, <EM CLASS="Emphasis">
X</EM>
[1,*] specifies the <EM CLASS="Emphasis">
Y</EM>
 values, and <EM CLASS="Emphasis">
X</EM>
[2,*] specifies the <EM CLASS="Emphasis">
Z</EM>
 values.</P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1013233">
 </A>
Y</H3>
<P CLASS="Body">
<A NAME="pgfId=1013234">
 </A>
A vector providing the <EM CLASS="Emphasis">
Y</EM>
 components of the vertices. The vector must contain at least three elements.</P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1013235">
 </A>
Z</H3>
<P CLASS="Body">
<A NAME="pgfId=1013236">
 </A>
A vector providing the <EM CLASS="Emphasis">
Z</EM>
 components of the vertices. The vector must contain at least three elements.</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Heading-1R">
<A NAME="pgfId=1013237">
 </A>
Keywords</H2>
<P CLASS="Body">
<A NAME="pgfId=1020258">
 </A>
Properties retrievable via <A HREF="idl301.htm#56846" CLASS="XRef">
IDLgrPolygon::GetProperty</A>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1013239">
 </A>
<A NAME="marker=1029639">
 </A>
BOTTOM (Get, Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1029640">
 </A>
Set this keyword to an RGB or Indexed color for drawing the backs of the polygons. (The <EM CLASS="Emphasis">
back</EM>
 of a polygon is the side opposite the normal direction). Setting a bottom color is only supported when the destination device uses RGB color mode.</P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1029638">
 </A>
<A NAME="marker=1023021">
 </A>
COLOR (Get, Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1013240">
 </A>
Set this keyword to an RGB or Indexed color for drawing polygons. The default color is [255, 255, 255] (white). If the TEXTURE_MAP property is used, the final color is modulated by the texture map pixel values. This keyword is ignored if the VERT_COLORS keyword is provided.</P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1013241">
 </A>
<A NAME="marker=1029646">
 </A>
DATA (Get, Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1029647">
 </A>
Set this keyword to a <EM CLASS="Emphasis">
2 x n</EM>
 or <EM CLASS="Emphasis">
3 x n</EM>
 array which defines, respectively, the 2D or 3D vertex data. DATA is equivalent to the optional arguments, <EM CLASS="Emphasis">
X</EM>
, <EM CLASS="Emphasis">
Y</EM>
, and <EM CLASS="Emphasis">
Z</EM>
. </P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1029645">
 </A>
<A NAME="marker=1023022">
 </A>
FILL_PATTERN (Get, Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1013245">
 </A>
Set this keyword equal to an object reference to an IDLgrPattern object (or an array of IDLgrPattern objects) to specify the fill pattern to use for filling the polygons. By default, FILL_PATTERN is set to a null object reference, specifying a solid fill.</P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1013246">
 </A>
<A NAME="marker=1029671">
 </A>
HIDDEN_LINES</H3>
<P CLASS="Body">
<A NAME="pgfId=1029672">
 </A>
Set this keyword to draw point and wireframe surfaces using hidden line (point) removal. By default, hidden line removal is disabled.</P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1049182">
 </A>
<A NAME="marker=1049181">
 </A>
HIDE (Get, Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1049183">
 </A>
Set this keyword to a boolean value indicating whether this object should be drawn:</P>
<UL>
<LI CLASS="Body-Bullet-2">
<A NAME="pgfId=1068497">
 </A>
0 = Draw graphic (the default)</LI>
<LI CLASS="Body-Bullet-2">
<A NAME="pgfId=1068498">
 </A>
1 = Do not draw graphic</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1029670">
 </A>
<A NAME="marker=1029925">
 </A>
LINESTYLE (Get, Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1060801">
 </A>
Set this keyword to indicate the line style that should be used to draw the polygon. The value can be either an integer value specifying a pre-defined line style, or a two-element vector specifying a stippling pattern.</P>
<P CLASS="Body">
<A NAME="pgfId=1060802">
 </A>
To use a pre-defined line style, set the LINESTYLE property equal to one of the following integer values:</P>
<UL>
<LI CLASS="Body-Bullet-2">
<A NAME="pgfId=1060803">
 </A>
0 = Solid line (the default)</LI>
<LI CLASS="Body-Bullet-2">
<A NAME="pgfId=1060804">
 </A>
1 = dotted</LI>
<LI CLASS="Body-Bullet-2">
<A NAME="pgfId=1060805">
 </A>
2 = dashed</LI>
<LI CLASS="Body-Bullet-2">
<A NAME="pgfId=1060806">
 </A>
3 = dash dot</LI>
<LI CLASS="Body-Bullet-2">
<A NAME="pgfId=1060807">
 </A>
4 = dash dot dot dot</LI>
<LI CLASS="Body-Bullet-2">
<A NAME="pgfId=1060808">
 </A>
5 = long dash</LI>
<LI CLASS="Body-Bullet-2">
<A NAME="pgfId=1060809">
 </A>
6 = no line drawn</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId=1060810">
 </A>
To define your own stippling pattern, specify a two-element vector [<EM CLASS="Emphasis">
repeat</EM>
, <EM CLASS="Emphasis">
bitmask</EM>
], where <EM CLASS="Emphasis">
repeat</EM>
 indicates the number of times consecutive runs of 1's or 0's in the <EM CLASS="Emphasis">
bitmask</EM>
 should be repeated. (That is, if three consecutive 0's appear in the <EM CLASS="Emphasis">
bitmask</EM>
 and the value of <EM CLASS="Emphasis">
repeat</EM>
 is 2, then the line that is drawn will have six consecutive bits turned off.) The value of <EM CLASS="Emphasis">
repeat</EM>
 must be in the range 1&nbsp;<EM CLASS="Symbol">
&#163;</EM>
&nbsp;<EM CLASS="Emphasis">
repeat</EM>
&nbsp;<EM CLASS="Symbol">
&#163;</EM>
&nbsp;255.</P>
<P CLASS="Body">
<A NAME="pgfId=1060811">
 </A>
The <EM CLASS="Emphasis">
bitmask</EM>
 indicates which pixels are drawn and which are not along the length of the line. <EM CLASS="Emphasis">
Bitmask</EM>
 is most conveniently specified as a 16-bit hexadecimal value.</P>
<P CLASS="Body">
<A NAME="pgfId=1060812">
 </A>
For example, <CODE CLASS="Code">
LINESTYLE = [2, 'F0F0'X]</CODE>
 describes a dashed line (8 bits on, 8 bits off, 8 bits on, 8 bits off).</P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1049043">
 </A>
<A NAME="marker=1049042">
 </A>
NAME (Get, Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1058311">
 </A>
Set this keyword equal to a string containing the name associated with this object. The default is the null string, ' '.</P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1029924">
 </A>
<A NAME="marker=1029867">
 </A>
NORMALS (Get, Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1029871">
 </A>
Set this keyword to a <I CLASS="Italic">
3 x n</I>
 array of unit polygon normals at each vertex. If this keyword is not set, vertex normals are computed by averaging shared polygon normals at each vertex. Normals are computed using the Right Hand Rule; that is, if the polygon is facing the viewer, vertices are taken in counterclockwise order. To remove previously specified normals, set NORMALS to a scalar.</P>
<UL>
<P CLASS="Note"><b><FONT SIZE=+1>NOTE: </FONT></b>
<A NAME="pgfId=1166161">
 </A>
Computing normals is a computationally expensive operation. Rendering speed increases significantly if you supply the surface normals explicitly. You can compute the array of polygon normals used by this keyword automatically. See &quot;COMPUTE_MESH_NORMALS&quot; in the <I CLASS="Italic">
IDL Reference Guide</I>
 for details.</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1029862">
 </A>
<A NAME="marker=1023023">
 </A>
POLYGONS (Get, Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1013247">
 </A>
Set this keyword to an array of polygon descriptions. A polygon description is an integer or longword array of the form: [<I CLASS="Italic">
n</I>
, i<SUB CLASS="Subscript">
0</SUB>
, i<SUB CLASS="Subscript">
1</SUB>
, ..., i<SUB CLASS="Subscript">
n-1</SUB>
<I CLASS="Italic">
</I>
], where <I CLASS="Italic">
n</I>
 is the number of vertices that define the polygon, and i<SUB CLASS="Subscript">
0</SUB>
..i<I CLASS="Italic">
n</I>
<SUB CLASS="Subscript">
-1</SUB>
<I CLASS="Italic">
</I>
 are indices into the <EM CLASS="Emphasis">
X</EM>
, <EM CLASS="Emphasis">
Y</EM>
, and <EM CLASS="Emphasis">
Z</EM>
 arguments that represent the polygon vertices. To ignore an entry in the POLYGONS array, set the vertex count, <I CLASS="Italic">
n</I>
, to 0. To end the drawing list, even if additional array space is available, set <I CLASS="Italic">
n</I>
 to -1. If this keyword is not specified, a single polygon will be generated.</P>
<UL>
<P CLASS="Note"><b><FONT SIZE=+1>NOTE: </FONT></b>
<A NAME="pgfId=1030112">
 </A>
The connectivity array described by POLYGONS allows an individual object to contain more than one polygon. Vertex, normal, and color information can be shared by the multiple polygons. Consequently, the polygon object can represent an entire mesh and compute reasonable normal estimates in most cases.</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1013248">
 </A>
<A NAME="marker=1023024">
 </A>
REJECT (Get, Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1013249">
 </A>
Set this keyword to an integer value to reject polygons as being hidden depending on the orientation of their normals. Select from one of the following values:</P>
<UL>
<LI CLASS="Body-Bullet-2">
<A NAME="pgfId=1029849">
 </A>
0 = No polygons are hidden</LI>
<LI CLASS="Body-Bullet-2">
<A NAME="pgfId=1029851">
 </A>
1 = Polygons whose normals point away from the viewer are hidden</LI>
<LI CLASS="Body-Bullet-2">
<A NAME="pgfId=1029852">
 </A>
2 = Polygons whose normals point toward the viewer are hidden</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId=1060476">
 </A>
Set this keyword to zero to draw all polygons regardless of the direction of their normals.</P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1060483">
 </A>
<A NAME="marker=1060482">
 </A>
RESET_DATA (Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1060478">
 </A>
Set this keyword to treat the data provided via the DATA property as a new data set unique to this object, rather than overwriting data that is shared by other objects. There is no reason to use this keyword if the object on which the property is being set does not currently share data with another object (that is, if the SHARE_DATA property is not in use). This keyword has no effect if no new data is provided via the DATA property.</P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1060480">
 </A>
<A NAME="marker=1060477">
 </A>
SHADE_RANGE (Get, Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1060479">
 </A>
Set this keyword to a two-element array that specifies the range of pixel values (color indices) to use for shading. The first element is the color index for the darkest pixel. The second element is the color index for the brightest pixel. The default is [0,&nbsp;255]. This keyword is ignored when the polygons are drawn to a graphics destination that uses the RGB color model.</P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1050052">
 </A>
<A NAME="marker=1050051">
 </A>
SHADING (Get, Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1050053">
 </A>
Set this keyword to an integer representing the type of shading to use:</P>
<UL>
<LI CLASS="Body-Bullet-2">
<A NAME="pgfId=1050054">
 </A>
0 = Flat (default): The color of the first vertex in each polygon is used to define the color for the entire polygon. The color has a constant intensity based upon the normal vector.</LI>
<LI CLASS="Body-Bullet-2">
<A NAME="pgfId=1050055">
 </A>
1 = Gouraud: The colors along each line are interpolated between vertex colors, and then along scanlines from each of the edge intensities.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId=1050056">
 </A>
Gouraud shading may be slower than flat shading, but results in a smoother appearance.</P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1013254">
 </A>
<A NAME="marker=1023027">
 </A>
SHARE_DATA (Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1013255">
 </A>
Set this keyword to an object with which data is to be shared by this polygon(s). Polygons may only share data with another polygons object or a polyline. The SHARE_DATA property is intended for use when data values are not set via an argument to the object's Init method or by setting the object's DATA property.</P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1013256">
 </A>
<A NAME="marker=1029903">
 </A>
STYLE (Get, Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1029907">
 </A>
Set this keyword to specify how the polygon should be drawn:</P>
<UL>
<LI CLASS="Body-Bullet-2">
<A NAME="pgfId=1029908">
 </A>
0 = Points: Only vertices are drawn, using either COLOR or VERT_COLORS.</LI>
<LI CLASS="Body-Bullet-2">
<A NAME="pgfId=1029911">
 </A>
1 = Lines: Each polygon is outlined by connecting vertices.</LI>
<LI CLASS="Body-Bullet-2">
<A NAME="pgfId=1029978">
 </A>
2 = Filled (default): The polygon faces are shaded.</LI>
<P CLASS="Note"><b><FONT SIZE=+1>NOTE: </FONT></b>
<A NAME="pgfId=1029979">
 </A>
Texturing is in effect only when STYLE = 2 (Filled).</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1029981">
 </A>
<A NAME="marker=1029980">
 </A>
TEXTURE_COORD (Get, Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1029982">
 </A>
A 2 x <EM CLASS="Emphasis">
n</EM>
 array containing the texture map coordinates for each of the <EM CLASS="Emphasis">
n</EM>
 polygon vertices. Use this keyword in conjunction with the TEXTURE_MAP keyword to wrap images over 2D and 3D polygons. Default coordinates are not provided.</P>
<P CLASS="Body">
<A NAME="pgfId=1069015">
 </A>
Texture coordinates are normalized. This means that the <EM CLASS="Emphasis">
m</EM>
 x <EM CLASS="Emphasis">
n</EM>
 image object specified via the TEXTURE_MAP property is mapped into the range [0.0, 0.0] to [1.0, 1.0]. If texture coordinates outside the range [0.0, 0.0] to [1.0, 1.0] are specified, the image object is tiled into the larger range.</P>
<P CLASS="Body">
<A NAME="pgfId=1069020">
 </A>
For example, suppose the image object specified via TEXTURE_MAP is a 256 x 256 array, and we want to map the image into a square two units on each side. To completely fill the square with a single copy of the image:</P>
<P CLASS="Code">
<A NAME="pgfId=1069021">
 </A>
TEXTURE_COORD = [[0,0], [1,0], [1,1], [0,1]]</P>
<P CLASS="Body">
<A NAME="pgfId=1069022">
 </A>
To fill the square with four tiled copies of the image:</P>
<P CLASS="Code">
<A NAME="pgfId=1069027">
 </A>
TEXTURE_COORD = [[0,0], [2,0], [2,2], [0,2]]</P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1013258">
 </A>
<A NAME="marker=1023029">
 </A>
TEXTURE_INTERP (Get, Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1013259">
 </A>
Set this keyword to indicate that bilinear sampling is to be used for texture mapping an image onto the polygon(s). The default is nearest neighbor sampling.</P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1013260">
 </A>
<A NAME="marker=1023030">
 </A>
TEXTURE_MAP (Get, Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1013261">
 </A>
Set this keyword to the object reference of an IDLgrImage object to be texture mapped onto the polygons. The tiling or mapping of the texture is defined expressly by TEXTURE_COORD. If this keyword is omitted, polygons are filled with the color specified by the COLOR or VERT_COLORS property. If both TEXTURE_MAP and COLORS or VERT_COLORS properties exist, the color of the texture is modulated by the base color of the object. (This means that for the clearest display of the texture image, the COLOR property should be set equal to [255,255,255].) To remove a texture map, set TEXTURE_MAP equal to a null object reference.</P>
<UL>
<P CLASS="Note"><b><FONT SIZE=+1>NOTE: </FONT></b>
<A NAME="pgfId=1069031">
 </A>
Texture mapping is disabled when rendering to a destination object that uses Indexed color mode.</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1013262">
 </A>
<A NAME="marker=1029916">
 </A>
THICK (Get, Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1029917">
 </A>
Set this keyword to an integer value between 1 and 10, specifying the size of the points or the thickness of the lines to be drawn when STYLE is set to either 0 (Points) or 1 (Lines), in pixels. The default is one pixel.</P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1013267">
 </A>
<A NAME="marker=1023032">
 </A>
VERT_COLORS (Get, Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1013268">
 </A>
Set this keyword to a vector of colors to be used to draw at each vertex. Color is interpolated between vertices if SHADING is set to 1 (Gouraud). If there are more vertices than elements in VERT_COLORS, the elements of VERT_COLORS are cyclically repeated. By default, the polygons are all drawn in the single color provided by the COLOR keyword. To remove vertex colors, set VERT_COLORS to a scalar.</P>
<UL>
<P CLASS="Note"><b><FONT SIZE=+1>NOTE: </FONT></b>
<A NAME="pgfId=1068760">
 </A>
If the polygon object is being rendered on a destination device that uses the Indexed color model, and the view that contains the polygon also contains one or more light objects, the VERT_COLORS property is ignored and the SHADE_RANGE property is used instead.</LI>
</UL>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1039637">
 </A>
<A NAME="marker=1039636">
 </A>
XCOORD_CONV (Get, Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1039638">
 </A>
Set this keyword to a vector, [<EM CLASS="Emphasis">
s</EM>
<SUB CLASS="Subscript">
0</SUB>
, <EM CLASS="Emphasis">
s</EM>
<SUB CLASS="Subscript">
1</SUB>
], of scaling factors used to convert <EM CLASS="Emphasis">
X</EM>
 coordinates from data units to normalized units. The formula for the conversion is as follows:</P>
<P CLASS="Body-Indent">
<A NAME="pgfId=1039639">
 </A>
Normalized<EM CLASS="Emphasis">
X</EM>
 = <EM CLASS="Emphasis">
s</EM>
<SUB CLASS="Subscript">
0</SUB>
 + <EM CLASS="Emphasis">
s</EM>
<SUB CLASS="Subscript">
1</SUB>
 * Data<EM CLASS="Emphasis">
X</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId=1039640">
 </A>
Recommended values are:</P>
<P CLASS="Body-Indent">
<A NAME="pgfId=1039641">
 </A>
[(-<EM CLASS="Emphasis">
X</EM>
<SUB CLASS="Subscript">
min</SUB>
)/(<EM CLASS="Emphasis">
X</EM>
<SUB CLASS="Subscript">
max</SUB>
-<EM CLASS="Emphasis">
X</EM>
<SUB CLASS="Subscript">
min</SUB>
), 1/(<EM CLASS="Emphasis">
X</EM>
<SUB CLASS="Subscript">
max</SUB>
-<EM CLASS="Emphasis">
X</EM>
<SUB CLASS="Subscript">
min</SUB>
)]</P>
<P CLASS="Body">
<A NAME="pgfId=1039642">
 </A>
The default is [0.0, 1.0].</P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1039644">
 </A>
<A NAME="marker=1039643">
 </A>
YCOORD_CONV (Get, Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1039645">
 </A>
Set this keyword to a vector, [<EM CLASS="Emphasis">
s</EM>
<SUB CLASS="Subscript">
0</SUB>
, <EM CLASS="Emphasis">
s</EM>
<SUB CLASS="Subscript">
1</SUB>
], of scaling factors used to convert <EM CLASS="Emphasis">
Y</EM>
 coordinates from data units to normalized units. The formula for the conversion is as follows:</P>
<P CLASS="Body-Indent">
<A NAME="pgfId=1039646">
 </A>
Normalized<EM CLASS="Emphasis">
Y</EM>
 = <EM CLASS="Emphasis">
s</EM>
<SUB CLASS="Subscript">
0</SUB>
 + <EM CLASS="Emphasis">
s</EM>
<SUB CLASS="Subscript">
1</SUB>
 * Data<EM CLASS="Emphasis">
Y</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId=1039647">
 </A>
Recommended values are:</P>
<P CLASS="Body-Indent">
<A NAME="pgfId=1039648">
 </A>
[(-<EM CLASS="Emphasis">
Y</EM>
<SUB CLASS="Subscript">
min</SUB>
)/(<EM CLASS="Emphasis">
Y</EM>
<SUB CLASS="Subscript">
max</SUB>
-<EM CLASS="Emphasis">
Y</EM>
<SUB CLASS="Subscript">
min</SUB>
), 1/(<EM CLASS="Emphasis">
Y</EM>
<SUB CLASS="Subscript">
max</SUB>
-<EM CLASS="Emphasis">
Y</EM>
<SUB CLASS="Subscript">
min</SUB>
)]</P>
<P CLASS="Body">
<A NAME="pgfId=1039649">
 </A>
The default is [0.0, 1.0].</P>
</DIV>
<DIV>
<H3 CLASS="Argument">
<A NAME="pgfId=1039651">
 </A>
<A NAME="marker=1039650">
 </A>
ZCOORD_CONV (Get, Set)</H3>
<P CLASS="Body">
<A NAME="pgfId=1039652">
 </A>
Set this keyword to a vector, [<EM CLASS="Emphasis">
s</EM>
<SUB CLASS="Subscript">
0</SUB>
, <EM CLASS="Emphasis">
s</EM>
<SUB CLASS="Subscript">
1</SUB>
], of scaling factors used to convert <EM CLASS="Emphasis">
Z</EM>
 coordinates from data units to normalized units. The formula for the conversion is as follows:</P>
<P CLASS="Body-Indent">
<A NAME="pgfId=1039653">
 </A>
Normalized<EM CLASS="Emphasis">
Z</EM>
 = <EM CLASS="Emphasis">
s</EM>
<SUB CLASS="Subscript">
0</SUB>
 + <EM CLASS="Emphasis">
s</EM>
<SUB CLASS="Subscript">
1</SUB>
 * Data<EM CLASS="Emphasis">
Z</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId=1039654">
 </A>
Recommended values are:</P>
<P CLASS="Body-Indent">
<A NAME="pgfId=1039655">
 </A>
[(-<EM CLASS="Emphasis">
Z</EM>
<SUB CLASS="Subscript">
min</SUB>
)/(<EM CLASS="Emphasis">
Z</EM>
<SUB CLASS="Subscript">
max</SUB>
-<EM CLASS="Emphasis">
Z</EM>
<SUB CLASS="Subscript">
min</SUB>
), 1/(<EM CLASS="Emphasis">
Z</EM>
<SUB CLASS="Subscript">
max</SUB>
-<EM CLASS="Emphasis">
Z</EM>
<SUB CLASS="Subscript">
min</SUB>
)]</P>
<P CLASS="Body">
<A NAME="pgfId=1039656">
 </A>
The default is [0.0, 1.0].</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Method-Name">
<HR><A HREF="#top"><IMG SRC="buttonup.gif" ALIGN="right" BORDER=0></A>
<A NAME="pgfId=1006022">
 </A>
<A NAME="84664">
 </A>
IDLgrPolygon::SetProperty</H2>
<P CLASS="Body">
<A NAME="pgfId=1006029">
 </A>
The IDLgrPolygon::<A NAME="marker=1052287">
 </A>
SetProperty procedure method sets the value of the property or group of properties for the polygons. <STRONG CLASS="Stone-Semibold">
<A HREF="idl301.htm#46829" CLASS="XRef">
IDLgrPolygon</A>
 </STRONG>
is described above.</P>


</DIV>
<DIV>
<H2 CLASS="Heading-1R">
<A NAME="pgfId=1006030">
 </A>
Calling Sequence</H2>
<P CLASS="Body">
<A NAME="pgfId=1006031">
 </A>
<EM CLASS="Emphasis">
Obj</EM>
 <CODE CLASS="Code">
-&gt;</CODE>
<EM CLASS="Emphasis">
[IDLgrPolygon::]</EM>
SetProperty</P>
</DIV>
<DIV>
<H2 CLASS="Heading-1R">
<A NAME="pgfId=1006032">
 </A>
Arguments</H2>
<P CLASS="Body">
<A NAME="pgfId=1006033">
 </A>
There are no arguments for this method.</P>
</DIV>
<DIV>
<H2 CLASS="Heading-1R">
<A NAME="pgfId=1006034">
 </A>
Keywords</H2>
<P CLASS="Body">
<A NAME="pgfId=1016680">
 </A>
Any keyword to <A HREF="idl2f5.htm#17584" CLASS="XRef">
IDLgrPolygon::Init</A>
</DIV>
</BODY>
</HTML>
